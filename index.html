<!-- START OF FILE ËΩ¨Êç¢_‰øÆÂ§çÁâà_v2.5.html -->

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Sing-box Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <style>
        :root {
            --bg: #0f0f12;
            --surface: #1b1b1f;
            --surface-hover: #27272c;
            --primary: #5e6ad2;
            --text-main: #ededed;
            --text-sub: #a1a1aa;
            --border: #2e2e32;
            --success: #22c55e;
            --warning: #f59e0b;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .navbar {
            padding: 0 24px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border);
            background: rgba(15, 15, 18, 0.8);
            backdrop-filter: blur(12px);
            z-index: 10;
        }

        .navbar h1 {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tag {
            font-size: 11px;
            background: var(--surface-hover);
            padding: 2px 8px;
            border-radius: 12px;
            color: var(--text-sub);
            border: 1px solid var(--border);
        }

        .main-content {
            flex: 1;
            display: flex;
            padding: 20px;
            gap: 20px;
            overflow: hidden;
        }

        .panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--surface);
            border-radius: 12px;
            border: 1px solid var(--border);
            overflow: hidden;
        }

        .panel-header {
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.02);
            border-bottom: 1px solid var(--border);
        }

        .panel-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-sub);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .editor {
            flex: 1;
            background: transparent;
            border: none;
            padding: 16px;
            color: #d4d4d4;
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: none;
            outline: none;
            white-space: pre;
        }

        .btn {
            background: var(--surface-hover);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover { background: #333; border-color: #444; }
        .btn-primary { background: var(--primary); border-color: var(--primary); color: white; }
        .btn-primary:hover { background: #4e5ac0; }

        .status-bar {
            padding: 0 24px;
            height: 36px;
            background: var(--surface);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-sub);
        }

        .format-badge {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-sub);
            margin-right: 6px;
        }
        .format-badge.active { background: var(--success); }
        .format-badge.error { background: var(--warning); }

        @media (max-width: 768px) {
            .main-content { flex-direction: column; }
            .navbar { padding: 0 16px; }
        }
    </style>
</head>
<body>

    <div class="navbar">
        <h1>
            Sing-box Converter
            <span class="tag">v2.5 AllProtoFix</span>
        </h1>
        <div style="display: flex; gap: 10px;">
            <button class="btn btn-primary" onclick="convert()">‚ö° ËΩ¨Êç¢ÈÖçÁΩÆ</button>
        </div>
    </div>

    <div class="main-content">
        <div class="panel">
            <div class="panel-header">
                <span class="panel-title">üìù ËæìÂÖ• (ÊîØÊåÅ SS/Trojan/VLESS/VMess)</span>
                <button class="btn" onclick="clearInput()">Ê∏ÖÁ©∫</button>
            </div>
            <textarea id="inputArea" class="editor" placeholder="Âú®Ê≠§Á≤òË¥¥ÈÖçÁΩÆÂÜÖÂÆπ..."></textarea>
        </div>

        <div class="panel">
            <div class="panel-header">
                <span class="panel-title">‚öôÔ∏è ËæìÂá∫ (Sing-box JSON)</span>
                <button class="btn" onclick="copyResult()">üìã Â§çÂà∂</button>
            </div>
            <textarea id="outputArea" class="editor" readonly placeholder="Á≠âÂæÖËΩ¨Êç¢..."></textarea>
        </div>
    </div>

    <div class="status-bar">
        <div style="display: flex; align-items: center;">
            <span id="statusBadge" class="format-badge"></span>
            <span id="statusText">Á≠âÂæÖËæìÂÖ•</span>
        </div>
        <span id="statsText">ËäÇÁÇπÊï∞: 0</span>
    </div>

    <script>
        // ==========================================
        // 1. Ê†∏ÂøÉÊ®°Êùø (Â∑≤ÊõøÊç¢‰∏∫ccs.txt‰∏≠ÁöÑÈÖçÁΩÆ)
        // ==========================================
        const TEMPLATE = {
            "dns": {
                "servers": [
                    {
                        "tag": "local",
                        "type": "https",
                        "server": "223.5.5.5"
                    },
                    {
                        "tag": "google",
                        "type": "https",
                        "server": "8.8.8.8",
                        "detour": "proxy"
                    },
                    {
                        "tag": "cloudflare",
                        "type": "https",
                        "server": "1.1.1.1",
                        "detour": "proxy"
                    },
                    {
                        "tag": "ali",
                        "type": "https",
                        "server": "223.5.5.5"
                    },
                    {
                        "tag": "fakeip",
                        "type": "fakeip",
                        "inet4_range": "198.18.0.0/15",
                        "inet6_range": "fc00::/18"
                    }
                ],
                "rules": [
                    {
                        "clash_mode": "Direct",
                        "action": "route",
                        "server": "ali"
                    },
                    {
                        "clash_mode": "Global",
                        "action": "route",
                        "server": "fakeip"
                    },
                    {
                        "query_type": "HTTPS",
                        "action": "reject"
                    },
                    {
                        "rule_set": "cn_domain",
                        "action": "route",
                        "server": "ali"
                    },
                    {
                        "rule_set": "geosite-cn",
                        "server": "ali"
                    },
                    {
                        "rule_set": [
                            "geosite-google",
                            "geosite-netflix",
                            "geosite-youtube"
                        ],
                        "server": "google"
                    },
                    {
                        "rule_set": "geosite_adguard",
                        "action": "reject",
                        "disable_cache": true
                    },
                    {
                        "rule_set": "geosite-category-ads-all",
                        "action": "reject",
                        "disable_cache": true
                    },
                    {
                        "rule_set": "geosite_ads",
                        "action": "reject",
                        "disable_cache": true
                    },
                    {
                        "query_type": [
                            "A",
                            "AAAA"
                        ],
                        "action": "route",
                        "server": "fakeip",
                        "rewrite_ttl": 1
                    }
                ],
                "final": "google",
                "strategy": "ipv4_only",
                "independent_cache": true
            },
            "inbounds": [
                {
                    "type": "tun",
                    "tag": "tun-in",
                    "address": [
                        "172.19.0.1/28"
                    ],
                    "mtu": 1280,
                    "stack": "mixed",
                    "auto_route": true,
                    "strict_route": true,
                    "sniff": true,
                    "sniff_override_destination": false,
                    "platform": {
                        "http_proxy": {
                            "enabled": true,
                            "server": "127.0.0.1",
                            "server_port": 7890
                        }
                    }
                },
                {
                    "type": "mixed",
                    "tag": "mixed-in",
                    "listen": "127.0.0.1",
                    "listen_port": 7890,
                    "sniff": true,
                    "sniff_override_destination": false,
                    "set_system_proxy": false
                }
            ],
            "outbounds": [
                {
                    "type": "direct",
                    "tag": "DIRECT"
                },
                {
                    "type": "block",
                    "tag": "BLOCK"
                },
                {
                    "type": "dns",
                    "tag": "DNS-OUT"
                },
                {
                    "type": "selector",
                    "tag": "proxy",
                    "outbounds": [
                        "auto",
                        "DIRECT"
                    ],
                    "default": "auto",
                    "interrupt_exist_connections": false
                },
                {
                    "type": "urltest",
                    "tag": "auto",
                    "outbounds": [],
                    "url": "https://www.gstatic.com/generate_204",
                    "interval": "3m",
                    "tolerance": 50,
                    "idle_timeout": "30m",
                    "interrupt_exist_connections": false
                },
                {
                    "type": "selector",
                    "tag": "google",
                    "outbounds": [
                        "proxy",
                        "auto",
                        "DIRECT"
                    ],
                    "default": "proxy",
                    "interrupt_exist_connections": false
                },
                {
                    "type": "selector",
                    "tag": "apple",
                    "outbounds": [
                        "DIRECT",
                        "proxy"
                    ],
                    "default": "DIRECT",
                    "interrupt_exist_connections": false
                },
                {
                    "type": "selector",
                    "tag": "telegram",
                    "outbounds": [
                        "proxy",
                        "auto"
                    ],
                    "default": "proxy",
                    "interrupt_exist_connections": false
                },
                {
                    "type": "selector",
                    "tag": "bilibili",
                    "outbounds": [
                        "DIRECT",
                        "proxy"
                    ],
                    "default": "DIRECT",
                    "interrupt_exist_connections": false
                },
                {
                    "type": "selector",
                    "tag": "netflix",
                    "outbounds": [
                        "proxy",
                        "auto"
                    ],
                    "default": "proxy",
                    "interrupt_exist_connections": false
                },
                {
                    "type": "selector",
                    "tag": "bahamut",
                    "outbounds": [
                        "proxy",
                        "auto"
                    ],
                    "default": "proxy",
                    "interrupt_exist_connections": false
                },
                {
                    "type": "selector",
                    "tag": "youtube",
                    "outbounds": [
                        "proxy",
                        "auto"
                    ],
                    "default": "proxy",
                    "interrupt_exist_connections": false
                },
                {
                    "type": "selector",
                    "tag": "openai",
                    "outbounds": [
                        "proxy",
                        "auto"
                    ],
                    "default": "proxy",
                    "interrupt_exist_connections": false
                },
                {
                    "type": "selector",
                    "tag": "GLOBAL",
                    "outbounds": [
                        "DIRECT",
                        "proxy",
                        "auto"
                    ],
                    "default": "DIRECT",
                    "interrupt_exist_connections": false
                },
                {
                    "type": "selector",
                    "tag": "cn",
                    "outbounds": [
                        "DIRECT",
                        "proxy"
                    ],
                    "default": "DIRECT",
                    "interrupt_exist_connections": false
                },
                {
                    "type": "selector",
                    "tag": "final",
                    "outbounds": [
                        "proxy",
                        "DIRECT"
                    ],
                    "default": "proxy",
                    "interrupt_exist_connections": false
                }
            ],
            "route": {
                "rules": [
                    {
                        "protocol": "quic",
                        "action": "reject"
                    },
                    {
                        "type": "logical",
                        "mode": "or",
                        "rules": [
                            {
                                "port": 53
                            },
                            {
                                "protocol": "dns"
                            }
                        ],
                        "action": "route",
                        "outbound": "DNS-OUT"
                    },
                    {
                        "rule_set": "geosite-telegram",
                        "action": "route",
                        "outbound": "telegram"
                    },
                    {
                        "rule_set": [
                            "telegram_ip",
                            "telegram_domain"
                        ],
                        "action": "route",
                        "outbound": "telegram"
                    },
                    {
                        "action": "sniff",
                        "sniffer": [
                            "http",
                            "tls",
                            "quic",
                            "dns"
                        ],
                        "timeout": "500ms"
                    },
                    {
                        "protocol": "dns",
                        "action": "route",
                        "outbound": "DNS-OUT"
                    },
                    {
                        "clash_mode": "Direct",
                        "action": "route",
                        "outbound": "DIRECT"
                    },
                    {
                        "clash_mode": "Global",
                        "action": "route",
                        "outbound": "GLOBAL"
                    },
                    {
                        "network": "udp",
                        "port": 443,
                        "action": "route",
                        "outbound": "BLOCK"
                    },
                    {
                        "ip_is_private": true,
                        "action": "route",
                        "outbound": "DIRECT"
                    },
                    {
                        "rule_set": "geosite-cn",
                        "action": "route",
                        "outbound": "DIRECT"
                    },
                    {
                        "rule_set": "geosite-bilibili",
                        "action": "route",
                        "outbound": "bilibili"
                    },
                    {
                        "rule_set": "geosite-apple",
                        "action": "route",
                        "outbound": "apple"
                    },
                    {
                        "rule_set": "geosite_adguard",
                        "action": "route",
                        "outbound": "BLOCK"
                    },
                    {
                        "rule_set": "geosite-category-ads-all",
                        "action": "route",
                        "outbound": "BLOCK"
                    },
                    {
                        "rule_set": "geosite_ads",
                        "action": "route",
                        "outbound": "BLOCK"
                    },
                    {
                        "rule_set": "geosite-google",
                        "action": "route",
                        "outbound": "google"
                    },
                    {
                        "rule_set": "geosite-netflix",
                        "action": "route",
                        "outbound": "netflix"
                    },
                    {
                        "rule_set": "geosite-youtube",
                        "action": "route",
                        "outbound": "youtube"
                    },
                    {
                        "rule_set": "geosite-openai",
                        "action": "route",
                        "outbound": "openai"
                    },
                    {
                        "rule_set": "geosite-bahamut",
                        "action": "route",
                        "outbound": "bahamut"
                    },
                    {
                        "rule_set": "bilibili_domain",
                        "action": "route",
                        "outbound": "bilibili"
                    },
                    {
                        "rule_set": [
                            "netflix_ip",
                            "netflix_domain"
                        ],
                        "action": "route",
                        "outbound": "netflix"
                    },
                    {
                        "rule_set": "bahamut_domain",
                        "action": "route",
                        "outbound": "bahamut"
                    },
                    {
                        "rule_set": "youtube_domain",
                        "action": "route",
                        "outbound": "youtube"
                    },
                    {
                        "rule_set": "openai_domain",
                        "action": "route",
                        "outbound": "openai"
                    },
                    {
                        "type": "logical",
                        "mode": "and",
                        "rules": [
                            {
                                "rule_set": "proxy_domain"
                            },
                            {
                                "invert": true,
                                "rule_set": [
                                    "geosite-cn",
                                    "geosite-apple",
                                    "geosite-google",
                                    "geosite-telegram",
                                    "geosite-netflix"
                                ]
                            }
                        ],
                        "action": "route",
                        "outbound": "proxy"
                    },
                    {
                        "rule_set": [
                            "google_ip",
                            "google_domain"
                        ],
                        "action": "route",
                        "outbound": "google"
                    },
                    {
                        "rule_set": [
                            "apple_ip",
                            "apple_domain"
                        ],
                        "action": "route",
                        "outbound": "apple"
                    },
                    {
                        "rule_set": [
                            "cn_ip",
                            "cn_domain"
                        ],
                        "action": "route",
                        "outbound": "cn"
                    }
                ],
                "rule_set": [
                    {
                        "tag": "geosite_ads",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/category-ads-all.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "type": "remote",
                        "tag": "geosite-category-ads-all",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-category-ads-all.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "type": "remote",
                        "tag": "geosite_adguard",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblocksingbox.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "type": "remote",
                        "tag": "geosite-apple",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-apple.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "type": "remote",
                        "tag": "geosite-bahamut",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-bahamut.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "type": "remote",
                        "tag": "geosite-bilibili",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-bilibili.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "type": "remote",
                        "tag": "geosite-cn",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-cn.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "type": "remote",
                        "tag": "geosite-google",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-google.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "type": "remote",
                        "tag": "geosite-netflix",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-netflix.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "type": "remote",
                        "tag": "geosite-openai",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-openai.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "type": "remote",
                        "tag": "geosite-telegram",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-telegram.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "type": "remote",
                        "tag": "geosite-youtube",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-youtube.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "tag": "apple_ip",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geoip/apple.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "tag": "apple_domain",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/apple.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "tag": "bahamut_domain",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/bahamut.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "tag": "bilibili_domain",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/bilibili.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "tag": "cn_ip",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geoip/cn.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "tag": "cn_domain",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/cn.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "tag": "google_ip",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geoip/google.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "tag": "google_domain",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/google.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "tag": "netflix_ip",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geoip/netflix.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "tag": "netflix_domain",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/netflix.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "tag": "openai_domain",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/openai.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "tag": "proxy_domain",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/geolocation-!cn.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "tag": "telegram_ip",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geoip/telegram.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "tag": "telegram_domain",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/telegram.srs",
                        "download_detour": "DIRECT"
                    },
                    {
                        "tag": "youtube_domain",
                        "type": "remote",
                        "format": "binary",
                        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/youtube.srs",
                        "download_detour": "DIRECT"
                    }
                ],
                "final": "proxy",
                "auto_detect_interface": true,
                "override_android_vpn": true,
                "default_domain_resolver": "local"
            },
            "experimental": {
                "clash_api": {
                    "external_controller": "127.0.0.1:9090",
                    "external_ui": "ui",
                    "external_ui_download_url": "https://ghfast.top/https://github.com/MetaCubeX/metacubexd/archive/refs/heads/gh-pages.zip",
                    "external_ui_download_detour": "DIRECT",
                    "default_mode": "rule"
                },
                "cache_file": {
                    "enabled": true,
                    "path": "cache.db",
                    "cache_id": "singbox",
                    "store_fakeip": true,
                    "store_rdrc": true
                }
            }
        };

        // ==========================================
        // 2. Â∑•ÂÖ∑ÂáΩÊï∞
        // ==========================================
        function safeBase64Decode(str) {
            str = str.replace(/-/g, '+').replace(/_/g, '/');
            while (str.length % 4) { str += '='; }
            try { return decodeURIComponent(escape(window.atob(str))); } catch { return window.atob(str); }
        }

        function setStatus(text, type = 'normal') {
            const badge = document.getElementById('statusBadge');
            const txt = document.getElementById('statusText');
            txt.textContent = text;
            badge.className = 'format-badge ' + (type === 'success' ? 'active' : (type === 'error' ? 'error' : ''));
        }

        function processWsPath(pathStr) {
            if (!pathStr) return { path: '/' };
            const edMatch = pathStr.match(/[?&]ed=(\d+)/);
            if (edMatch) {
                const maxEarlyData = parseInt(edMatch[1], 10);
                let newPath = pathStr.replace(/[?&]ed=\d+/, '');
                if (newPath.endsWith('?')) newPath = newPath.slice(0, -1);
                if (newPath === '') newPath = '/';
                return {
                    path: newPath,
                    max_early_data: maxEarlyData,
                    early_data_header_name: "Sec-WebSocket-Protocol"
                };
            }
            return { path: pathStr };
        }

        // ==========================================
        // 3. ËΩ¨Êç¢ÈÄªËæë (Clash -> Singbox)
        // ==========================================
        function mapClashToSingbox(p) {
            if (!p || !p.type) return null;
            const node = { tag: p.name || 'Unnamed' };
            
            if(p.type) node.type = p.type;
            if(p.server) node.server = p.server;
            if(p.port) node.server_port = parseInt(p.port, 10);
            if(p.password) node.password = p.password;
            if(p.uuid) node.uuid = p.uuid;
            
            // Helper for Clash WS
            const applyClashWs = (target, opts, headers) => {
                const wsInfo = processWsPath(opts.path || '/');
                target.transport = {
                    type: 'ws',
                    path: wsInfo.path,
                    headers: headers || {}
                };
                if(wsInfo.max_early_data) {
                    target.transport.max_early_data = wsInfo.max_early_data;
                    target.transport.early_data_header_name = wsInfo.early_data_header_name;
                }
            };

            if (p.type === 'ss' || p.type === 'shadowsocks') {
                node.type = 'shadowsocks';
                node.method = p.cipher;
                if (p.plugin === 'v2ray-plugin' && p['plugin-opts']) {
                    const opts = p['plugin-opts'];
                    if (opts.mode === 'websocket') {
                        applyClashWs(node, opts, opts.headers || (opts.host ? {Host: opts.host} : {}));
                        if (opts.tls) {
                            node.tls = {
                                enabled: true,
                                server_name: opts.servername || opts.host || p.server,
                                insecure: opts['skip-cert-verify'] || false
                            };
                        }
                    }
                }
            } else if (p.type === 'vmess') {
                node.type = 'vmess';
                node.alter_id = p.alterId !== undefined ? parseInt(p.alterId) : 0;
                node.security = p.cipher || 'auto';
                
                if (p.network === 'ws') {
                    applyClashWs(node, p['ws-opts'] || {}, p['ws-opts']?.headers);
                } else if (p.network === 'grpc') {
                    node.transport = { type: 'grpc', service_name: p['grpc-opts']?.['grpc-service-name'] };
                }

                if (p.tls) {
                    node.tls = { 
                        enabled: true, 
                        server_name: p.servername || p.server, 
                        utls: { enabled: true, fingerprint: p['client-fingerprint'] || 'chrome' },
                        insecure: p['skip-cert-verify'] || false
                    };
                }
            } else if (p.type === 'vless') {
                node.flow = p.flow || '';
                if (p.tls) {
                    node.tls = { 
                        enabled: true, 
                        server_name: p.servername || p.server,
                        utls: { enabled: true, fingerprint: p['client-fingerprint'] || 'chrome' },
                        insecure: p['skip-cert-verify'] || false
                    };
                    if (p['reality-opts']) {
                        node.tls.reality = {
                            enabled: true,
                            public_key: p['reality-opts']['public-key'],
                            short_id: p['reality-opts']['short-id']
                        };
                    }
                }
                if (p.network === 'ws') {
                    applyClashWs(node, p['ws-opts'] || {}, p['ws-opts']?.headers);
                } else if (p.network === 'grpc') {
                    node.transport = { type: 'grpc', service_name: p['grpc-opts']?.['grpc-service-name'] };
                }
                if (node.flow === '') delete node.flow;
            } else if (p.type === 'trojan') {
                node.tls = {
                    enabled: true,
                    server_name: p.sni || p.servername || p.server,
                    utls: { enabled: true, fingerprint: p['client-fingerprint'] || 'chrome' },
                    insecure: p['skip-cert-verify'] || false
                };
                if(p.network === 'ws') {
                    applyClashWs(node, p['ws-opts'] || {}, p['ws-opts']?.headers);
                }
            } else if (p.type === 'hysteria2') {
                node.type = 'hysteria2';
                node.tls = {
                    enabled: true,
                    server_name: p.sni || p.server,
                    utls: { enabled: true, fingerprint: p['client-fingerprint'] || 'chrome' },
                    insecure: p['skip-cert-verify'] || false
                };
                if(p.obfs) {
                    node.obfs = { type: 'salamander', password: p['obfs-password'] };
                }
            }
            return node;
        }

        // ==========================================
        // 4. ÈìæÊé•Ëß£ÊûêÈÄªËæë (‰øÆÂ§ç Trojan/SS WS ËØÜÂà´)
        // ==========================================
        function parseURI(line) {
            line = line.trim();
            if (!line) return null;

            try {
                const protocols = ['vless://', 'vmess://', 'ss://', 'trojan://', 'hysteria2://'];
                let startIndex = -1;
                for (let p of protocols) {
                    startIndex = line.indexOf(p);
                    if (startIndex !== -1) break;
                }
                
                if (startIndex === -1) return null;
                
                let urlStr = line.substring(startIndex);
                let uriObj;
                try {
                    uriObj = new URL(urlStr);
                } catch(e) {
                    const hashIndex = urlStr.indexOf('#');
                    if (hashIndex !== -1) {
                        const preHash = urlStr.substring(0, hashIndex);
                        const postHash = urlStr.substring(hashIndex + 1);
                        try {
                            uriObj = new URL(preHash);
                            uriObj.hash = '#' + encodeURIComponent(postHash);
                        } catch(ex) { return null; }
                    } else {
                        return null; 
                    }
                }

                const protocol = uriObj.protocol.replace(':', '');
                const params = Object.fromEntries(uriObj.searchParams);
                
                let tag = '';
                if (uriObj.hash) {
                    try { tag = decodeURIComponent(uriObj.hash.slice(1)); } 
                    catch { tag = uriObj.hash.slice(1); }
                }
                if (!tag && params.remarks) tag = decodeURIComponent(params.remarks);
                if (!tag) tag = 'Node';

                const node = {
                    tag: tag,
                    server: uriObj.hostname,
                    server_port: parseInt(uriObj.port, 10)
                };

                const applyWs = (targetNode, path, headers) => {
                    const wsInfo = processWsPath(path || '/');
                    targetNode.transport = { 
                        type: 'ws', 
                        path: wsInfo.path, 
                        headers: headers || {} 
                    };
                    if(wsInfo.max_early_data) {
                        targetNode.transport.max_early_data = wsInfo.max_early_data;
                        targetNode.transport.early_data_header_name = wsInfo.early_data_header_name;
                    }
                };

                if (protocol === 'vless') {
                    node.type = 'vless';
                    node.uuid = uriObj.username;
                    node.flow = params.flow || '';
                    if (node.flow === '') delete node.flow;

                    const isTls = params.security === 'tls' || params.security === 'reality' || params.tls === '1';
                    const isReality = params.security === 'reality';
                    
                    if (isTls) {
                        node.tls = {
                            enabled: true,
                            server_name: params.sni || params.peer || params.host || node.server,
                            utls: { enabled: true, fingerprint: params.fp || 'chrome' },
                            insecure: params.allowInsecure === '1'
                        };
                        if (isReality) {
                            node.tls.reality = {
                                enabled: true,
                                public_key: params.pbk,
                                short_id: params.sid || ''
                            };
                        }
                    }

                    const type = params.type || params.obfs;
                    if (type === 'ws' || type === 'websocket') {
                        applyWs(node, params.path, params.host ? {Host: params.host} : {});
                    } else if (type === 'grpc') {
                        node.transport = { type: 'grpc', service_name: params.serviceName || params.path || 'grpc' };
                    }

                } else if (protocol === 'vmess') {
                    if (!uriObj.username && urlStr.includes('vmess://')) {
                         const b64 = urlStr.replace('vmess://', '');
                         try {
                            const v = JSON.parse(safeBase64Decode(b64));
                            return mapClashToSingbox({
                                type: 'vmess', name: v.ps, server: v.add, port: v.port, uuid: v.id, alterId: v.aid,
                                cipher: v.scy || 'auto', network: v.net, tls: v.tls==='tls',
                                servername: v.sni || v.host, "ws-opts": {path: v.path, headers: {Host:v.host}},
                                "grpc-opts": {"grpc-service-name": v.path}
                            });
                         } catch(e) {}
                    }
                    
                    node.type = 'vmess';
                    node.uuid = uriObj.username;
                    node.alter_id = 0;
                    node.security = 'auto';

                    const type = params.obfs || params.type || 'tcp';
                    if (type === 'websocket' || type === 'ws') {
                        applyWs(node, params.path, params.obfsParam ? {Host: params.obfsParam} : {});
                    }
                    if (params.tls === '1') {
                        node.tls = { enabled: true, server_name: params.peer || params.obfsParam };
                    }

                } else if (protocol === 'trojan') {
                    node.type = 'trojan';
                    node.password = uriObj.username;
                    node.tls = {
                        enabled: true,
                        server_name: params.sni || params.peer || node.server,
                        utls: { enabled: true, fingerprint: 'chrome' }
                    };

                    // [Fix] Support Standard Trojan WS and Obfs
                    const type = params.type || params.obfs; // generic type check
                    const pluginStr = params.plugin || "";
                    
                    if (type === 'ws' || type === 'websocket') {
                        applyWs(node, params.path, params.host ? {Host: params.host} : {});
                    } else if (pluginStr.includes('obfs-local') && pluginStr.includes('websocket')) {
                        // Legacy obfs-plugin check
                        const pParts = pluginStr.split(';');
                        let wsPath = '/', wsHost = '';
                        pParts.forEach(p => {
                             if(p.includes('obfs-uri')) wsPath = p.split('=')[1];
                             if(p.includes('obfs-host')) wsHost = p.split('=')[1];
                        });
                        applyWs(node, wsPath, wsHost ? {Host: wsHost} : {});
                    }

                } else if (protocol === 'ss') {
                    let userInfo = uriObj.username;
                    if (!userInfo.includes(':')) {
                        const decoded = safeBase64Decode(userInfo);
                        if (decoded.includes(':')) userInfo = decoded;
                    }
                    let [method, password] = userInfo.split(':');
                    if (userInfo.includes('@')) {
                         const parts = userInfo.split('@');
                         const creds = parts[0].split(':');
                         method = creds[0];
                         password = creds[1];
                    }

                    node.type = 'shadowsocks';
                    node.method = method;
                    node.password = password;

                    const pluginStr = params.plugin || params['v2ray-plugin'] || "";
                    
                    // [Fix] Better SS Plugin/Obfs handling
                    if (pluginStr.includes('v2ray-plugin') || pluginStr.includes('obfs')) {
                         let opts = {};
                         if (!pluginStr.startsWith('{')) {
                             const parts = pluginStr.split(';');
                             parts.forEach(part => {
                                 const [k, v] = part.split('=');
                                 if(k) opts[k] = v || true;
                             });
                         }
                         
                         if (opts.mode === 'websocket' || opts.obfs === 'websocket') {
                             const host = opts.host || opts['obfs-host']; // handle obfs-host
                             applyWs(node, opts.path, host ? {Host: host} : {});
                             
                             if (opts.tls === true || opts.tls === 'true') {
                                 node.tls = {
                                     enabled: true,
                                     server_name: host || node.server
                                 };
                             }
                         }
                    }
                }
                return node.type ? node : null;
            } catch (e) { return null; }
        }

        // ==========================================
        // 5. ‰∏ªËΩ¨Êç¢ÈÄªËæë
        // ==========================================
        function convert() {
            const rawInput = document.getElementById('inputArea').value.trim();
            if (!rawInput) return;

            setStatus('Ê≠£Âú®Ëß£ÊûêÊ∑∑ÂêàÂÜÖÂÆπ...');
            let nodes = [];
            
            let input = rawInput;
            if (!input.includes('://') && !input.includes('outbounds') && !input.includes('proxies:')) {
                const decoded = safeBase64Decode(input);
                if (decoded && (decoded.includes('://') || decoded.includes('proxies:'))) {
                    input = decoded;
                }
            }

            const yamlLines = [];
            const lines = input.split(/\r?\n/);
            lines.forEach(line => {
                const trimmed = line.trim();
                if (trimmed.startsWith('- {') && trimmed.includes('name:') && trimmed.includes('type:')) {
                    yamlLines.push(trimmed);
                }
            });

            if (yamlLines.length > 0) {
                try {
                    const fakeYaml = "proxies:\n" + yamlLines.join("\n");
                    const parsed = jsyaml.load(fakeYaml);
                    if (parsed && parsed.proxies) {
                        parsed.proxies.forEach(p => {
                            const node = mapClashToSingbox(p);
                            if (node) nodes.push(node);
                        });
                    }
                } catch (e) { console.warn("YAML fragment parse error", e); }
            }

            if (input.includes('"outbounds"')) {
                try {
                    let jsonParsed = false;
                    try {
                        const j = JSON.parse(input);
                        if(j.outbounds) {
                            j.outbounds.forEach(o => {
                                if(o.type !== 'selector' && o.type !== 'urltest' && o.type!=='direct') nodes.push(o);
                            });
                            jsonParsed = true;
                        }
                    } catch(e) {}
                    if (!jsonParsed) {
                        const match = input.match(/"outbounds"\s*:\s*(\[[\s\S]*?\])/);
                        if (match) {
                            const arrStr = match[1];
                            const lastBracket = arrStr.lastIndexOf(']');
                            const validJsonArr = arrStr.substring(0, lastBracket+1);
                            const arr = JSON.parse(validJsonArr);
                            arr.forEach(o => {
                                if(o.type !== 'selector' && o.type !== 'urltest' && o.type!=='direct') nodes.push(o);
                            });
                        }
                    }
                } catch (e) { console.warn("JSON fragment parse error", e); }
            }

            lines.forEach(line => {
                if (line.trim().startsWith('- {')) return;
                const node = parseURI(line);
                if (node) nodes.push(node);
            });

            if (nodes.length === 0) {
                setStatus('Êú™ÊâæÂà∞ÊúâÊïàËäÇÁÇπ', 'error');
                return;
            }

            const uniqueNodes = [];
            const tagCounts = {};

            nodes.forEach(node => {
                let tag = node.tag || 'node';
                if (tagCounts[tag]) {
                    tagCounts[tag]++;
                    tag = `${tag} ${tagCounts[tag]}`;
                } else {
                    tagCounts[tag] = 1;
                }
                node.tag = tag;
                uniqueNodes.push(node);
            });

            const finalConfig = JSON.parse(JSON.stringify(TEMPLATE));
            const nodeTags = uniqueNodes.map(n => n.tag);
            
            // Êõ¥Êñ∞proxyÈÄâÊã©Âô®ÁöÑoutbounds
            const proxySelector = finalConfig.outbounds.find(o => o.tag === 'proxy');
            if (proxySelector && proxySelector.type === 'selector') {
                proxySelector.outbounds = ["auto", ...nodeTags, "DIRECT"];
            }
            
            // Êõ¥Êñ∞autoÊµãËØïÂô®ÁöÑoutbounds
            const autoUrlTest = finalConfig.outbounds.find(o => o.tag === 'auto');
            if (autoUrlTest && autoUrlTest.type === 'urltest') {
                autoUrlTest.outbounds = nodeTags;
            }

            // Â∞ÜÊâÄÊúâËΩ¨Êç¢ÂêéÁöÑËäÇÁÇπÊ∑ªÂä†Âà∞outboundsÊú´Â∞æ
            finalConfig.outbounds.push(...uniqueNodes);

            document.getElementById('outputArea').value = JSON.stringify(finalConfig, null, 2);
            setStatus(`ËΩ¨Êç¢ÊàêÂäü (Êù•Ê∫êÊ∑∑Âêà)`, 'success');
            document.getElementById('statsText').textContent = `ËäÇÁÇπÊï∞: ${uniqueNodes.length}`;
        }

        function clearInput() {
            document.getElementById('inputArea').value = '';
            document.getElementById('outputArea').value = '';
            setStatus('Â∑≤Ê∏ÖÁ©∫');
            document.getElementById('statsText').textContent = 'ËäÇÁÇπÊï∞: 0';
        }

        function copyResult() {
            const output = document.getElementById('outputArea');
            if (output.value) {
                output.select();
                document.execCommand('copy');
                setStatus('Â∑≤Â§çÂà∂', 'success');
            }
        }
    </script>
</body>
</html>