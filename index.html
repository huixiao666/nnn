<!-- START OF FILE è½¬æ¢_1.13.0_å†…æ ¸ç‰ˆ.html -->

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sing-box Converter (1.13.0 Config)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <style>
        :root {
            --bg: #0f0f12;
            --surface: #1b1b1f;
            --surface-hover: #27272c;
            --primary: #5e6ad2;
            --text-main: #ededed;
            --text-sub: #a1a1aa;
            --border: #2e2e32;
            --success: #22c55e;
            --warning: #f59e0b;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .navbar {
            padding: 0 24px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border);
            background: rgba(15, 15, 18, 0.8);
            backdrop-filter: blur(12px);
            z-index: 10;
        }

        .navbar h1 {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tag {
            font-size: 11px;
            background: var(--surface-hover);
            padding: 2px 8px;
            border-radius: 12px;
            color: var(--text-sub);
            border: 1px solid var(--border);
        }

        .main-content {
            flex: 1;
            display: flex;
            padding: 20px;
            gap: 20px;
            overflow: hidden;
        }

        .panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--surface);
            border-radius: 12px;
            border: 1px solid var(--border);
            overflow: hidden;
        }

        .panel-header {
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.02);
            border-bottom: 1px solid var(--border);
        }

        .panel-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-sub);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .editor {
            flex: 1;
            background: transparent;
            border: none;
            padding: 16px;
            color: #d4d4d4;
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: none;
            outline: none;
            white-space: pre;
        }

        .btn {
            background: var(--surface-hover);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover { background: #333; border-color: #444; }
        .btn-primary { background: var(--primary); border-color: var(--primary); color: white; }
        .btn-primary:hover { background: #4e5ac0; }

        .status-bar {
            padding: 0 24px;
            height: 36px;
            background: var(--surface);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-sub);
        }

        .format-badge {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-sub);
            margin-right: 6px;
        }
        .format-badge.active { background: var(--success); }
        .format-badge.error { background: var(--warning); }

        @media (max-width: 768px) {
            .main-content { flex-direction: column; }
            .navbar { padding: 0 16px; }
        }
    </style>
</head>
<body>

    <div class="navbar">
        <h1>
            Sing-box
            <span class="tag">æŒ‡å®š1.13.0-rc.1</span>
        </h1>
        <div style="display: flex; gap: 10px;">
            <button class="btn btn-primary" onclick="convert()">âš¡ è½¬æ¢é…ç½®</button>
        </div>
    </div>

    <div class="main-content">
        <div class="panel">
            <div class="panel-header">
                <span class="panel-title">ğŸ“ è¾“å…¥ (æ”¯æŒ SS/Trojan/VLESS/VMess/Clash YAML)</span>
                <button class="btn" onclick="clearInput()">æ¸…ç©º</button>
            </div>
            <textarea id="inputArea" class="editor" placeholder="åœ¨æ­¤ç²˜è´´é…ç½®å†…å®¹..."></textarea>
        </div>

        <div class="panel">
            <div class="panel-header">
                <span class="panel-title">âš™ï¸ è¾“å‡º (Sing-box JSON)</span>
                <button class="btn" onclick="copyResult()">ğŸ“‹ å¤åˆ¶</button>
            </div>
            <textarea id="outputArea" class="editor" readonly placeholder="ç­‰å¾…è½¬æ¢..."></textarea>
        </div>
    </div>

    <div class="status-bar">
        <div style="display: flex; align-items: center;">
            <span id="statusBadge" class="format-badge"></span>
            <span id="statusText">ç­‰å¾…è¾“å…¥</span>
        </div>
        <span id="statsText">èŠ‚ç‚¹æ•°: 0</span>
    </div>

    <script>
        // ==========================================
        // 1. æ ¸å¿ƒæ¨¡æ¿ (åŸºäº 1.13.0.txt)
        // ==========================================
        const TEMPLATE = {
  "dns": {
    "servers": [
      {
        "tag": "local",
        "type": "https",
        "server": "223.5.5.5"
      },
      {
        "tag": "google",
        "type": "https",
        "server": "8.8.8.8",
        "detour": "proxy"
      },
      {
        "tag": "cloudflare",
        "type": "https",
        "server": "1.1.1.1",
        "detour": "proxy"
      },
      {
        "tag": "ali",
        "type": "https",
        "server": "223.5.5.5"
      },
      {
        "tag": "fakeip",
        "type": "fakeip",
        "inet4_range": "198.18.0.0/15",
        "inet6_range": "fc00::/18"
      }
    ],
    "rules": [
      {
        "clash_mode": "Direct",
        "action": "route",
        "server": "ali"
      },
      {
        "clash_mode": "Global",
        "action": "route",
        "server": "fakeip"
      },
      {
        "query_type": "HTTPS",
        "action": "reject"
      },
      {
        "rule_set": "cn_domain",
        "action": "route",
        "server": "ali"
      },
      {
        "rule_set": "geosite-cn",
        "server": "ali"
      },
      {
        "rule_set": [
          "geosite-google",
          "geosite-netflix",
          "geosite-youtube"
        ],
        "server": "google"
      },
      {
        "rule_set": "geosite_adguard",
        "action": "reject",
        "disable_cache": true
      },
      {
        "rule_set": "geosite-category-ads-all",
        "action": "reject",
        "disable_cache": true
      },
      {
        "rule_set": "geosite_ads",
        "action": "reject",
        "disable_cache": true
      },
      {
        "query_type": [
          "A",
          "AAAA"
        ],
        "action": "route",
        "server": "fakeip",
        "rewrite_ttl": 1
      }
    ],
    "final": "google",
    "strategy": "ipv4_only",
    "independent_cache": true
  },
  "ntp": {
    "enabled": true,
    "server": "time.apple.com",
    "server_port": 123,
    "interval": "30m",
    "detour": "direct"
  },
  "inbounds": [
    {
      "type": "tun",
      "tag": "tun-in",
      "address": [
        "172.19.0.1/28"
      ],
      "mtu": 1280,
      "stack": "mixed",
      "auto_route": true,
      "strict_route": true,
      "sniff": true,
      "sniff_override_destination": false,
      "platform": {
        "http_proxy": {
          "enabled": true,
          "server": "127.0.0.1",
          "server_port": 7890
        }
      }
    },
    {
      "type": "mixed",
      "tag": "mixed-in",
      "listen": "127.0.0.1",
      "listen_port": 7890,
      "sniff": true,
      "sniff_override_destination": false,
      "set_system_proxy": false
    }
  ],
  "outbounds": [
    {
      "type": "direct",
      "tag": "direct"
    },
    {
      "type": "selector",
      "tag": "proxy",
      "outbounds": [
        "auto",
        "direct"
      ],
      "default": "auto",
      "interrupt_exist_connections": false
    },
    {
      "type": "urltest",
      "tag": "auto",
      "outbounds": [],
      "url": "https://www.gstatic.com/generate_204",
      "interval": "3m",
      "tolerance": 50,
      "idle_timeout": "30m",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "google",
      "outbounds": [
        "proxy",
        "auto",
        "direct"
      ],
      "default": "proxy",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "apple",
      "outbounds": [
        "direct",
        "proxy"
      ],
      "default": "direct",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "telegram",
      "outbounds": [
        "proxy",
        "auto"
      ],
      "default": "proxy",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "bilibili",
      "outbounds": [
        "direct",
        "proxy"
      ],
      "default": "direct",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "netflix",
      "outbounds": [
        "proxy",
        "auto"
      ],
      "default": "proxy",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "bahamut",
      "outbounds": [
        "proxy",
        "auto"
      ],
      "default": "proxy",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "youtube",
      "outbounds": [
        "proxy",
        "auto"
      ],
      "default": "proxy",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "openai",
      "outbounds": [
        "proxy",
        "auto"
      ],
      "default": "proxy",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "GLOBAL",
      "outbounds": [
        "direct",
        "proxy",
        "auto"
      ],
      "default": "direct",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "cn",
      "outbounds": [
        "direct",
        "proxy"
      ],
      "default": "direct",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "final",
      "outbounds": [
        "proxy",
        "direct"
      ],
      "default": "proxy",
      "interrupt_exist_connections": false
    }
  ],
  "route": {
    "rules": [
      {
        "protocol": "quic",
        "action": "reject"
      },
      {
        "type": "logical",
        "mode": "or",
        "rules": [
          {
            "port": 53
          },
          {
            "protocol": "dns"
          }
        ],
        "action": "hijack-dns"
      },
      {
        "rule_set": "geosite-telegram",
        "action": "route",
        "outbound": "telegram"
      },
      {
        "rule_set": [
          "telegram_ip",
          "telegram_domain"
        ],
        "action": "route",
        "outbound": "telegram"
      },
      {
        "action": "sniff",
        "sniffer": [
          "http",
          "tls",
          "quic",
          "dns"
        ],
        "timeout": "500ms"
      },
      {
        "protocol": "dns",
        "action": "hijack-dns"
      },
      {
        "clash_mode": "Direct",
        "action": "route",
        "outbound": "direct"
      },
      {
        "clash_mode": "Global",
        "action": "route",
        "outbound": "GLOBAL"
      },
      {
        "network": "udp",
        "port": 443,
        "action": "reject"
      },
      {
        "ip_is_private": true,
        "action": "route",
        "outbound": "direct"
      },
      {
        "rule_set": "geosite-cn",
        "action": "route",
        "outbound": "direct"
      },
      {
        "rule_set": "geosite-bilibili",
        "action": "route",
        "outbound": "bilibili"
      },
      {
        "rule_set": "geosite-apple",
        "action": "route",
        "outbound": "apple"
      },
      {
        "rule_set": "geosite_adguard",
        "action": "reject"
      },
      {
        "rule_set": "geosite-category-ads-all",
        "action": "reject"
      },
      {
        "rule_set": "geosite_ads",
        "action": "reject"
      },
      {
        "rule_set": "geosite-google",
        "action": "route",
        "outbound": "google"
      },
      {
        "rule_set": "geosite-netflix",
        "action": "route",
        "outbound": "netflix"
      },
      {
        "rule_set": "geosite-youtube",
        "action": "route",
        "outbound": "youtube"
      },
      {
        "rule_set": "geosite-openai",
        "action": "route",
        "outbound": "openai"
      },
      {
        "rule_set": "geosite-bahamut",
        "action": "route",
        "outbound": "bahamut"
      },
      {
        "rule_set": "bilibili_domain",
        "action": "route",
        "outbound": "bilibili"
      },
      {
        "rule_set": [
          "netflix_ip",
          "netflix_domain"
        ],
        "action": "route",
        "outbound": "netflix"
      },
      {
        "rule_set": "bahamut_domain",
        "action": "route",
        "outbound": "bahamut"
      },
      {
        "rule_set": "youtube_domain",
        "action": "route",
        "outbound": "youtube"
      },
      {
        "rule_set": "openai_domain",
        "action": "route",
        "outbound": "openai"
      },
      {
        "type": "logical",
        "mode": "and",
        "rules": [
          {
            "rule_set": "proxy_domain"
          },
          {
            "invert": true,
            "rule_set": [
              "geosite-cn",
              "geosite-apple",
              "geosite-google",
              "geosite-telegram",
              "geosite-netflix"
            ]
          }
        ],
        "action": "route",
        "outbound": "proxy"
      },
      {
        "rule_set": [
          "google_ip",
          "google_domain"
        ],
        "action": "route",
        "outbound": "google"
      },
      {
        "rule_set": [
          "apple_ip",
          "apple_domain"
        ],
        "action": "route",
        "outbound": "apple"
      },
      {
        "rule_set": [
          "cn_ip",
          "cn_domain"
        ],
        "action": "route",
        "outbound": "cn"
      }
    ],
    "rule_set": [
      {
        "tag": "geosite_ads",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/category-ads-all.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite-category-ads-all",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-category-ads-all.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite_adguard",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblocksingbox.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite-apple",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-apple.srs",
        "download_detour": "direct"
      },
      {
        "type": "remote",
        "tag": "geosite-bahamut",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-bahamut.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite-bilibili",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-bilibili.srs",
        "download_detour": "direct"
      },
      {
        "type": "remote",
        "tag": "geosite-cn",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-cn.srs",
        "download_detour": "direct"
      },
      {
        "type": "remote",
        "tag": "geosite-google",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-google.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite-netflix",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-netflix.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite-openai",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-openai.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite-telegram",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-telegram.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite-youtube",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-youtube.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "apple_ip",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geoip/apple.srs",
        "download_detour": "direct"
      },
      {
        "tag": "apple_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/apple.srs",
        "download_detour": "direct"
      },
      {
        "tag": "bahamut_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/bahamut.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "bilibili_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/bilibili.srs",
        "download_detour": "direct"
      },
      {
        "tag": "cn_ip",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geoip/cn.srs",
        "download_detour": "direct"
      },
      {
        "tag": "cn_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/cn.srs",
        "download_detour": "direct"
      },
      {
        "tag": "google_ip",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geoip/google.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "google_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/google.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "netflix_ip",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geoip/netflix.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "netflix_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/netflix.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "openai_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/openai.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "proxy_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/geolocation-!cn.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "telegram_ip",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geoip/telegram.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "telegram_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/telegram.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "youtube_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/youtube.srs",
        "download_detour": "proxy"
      }
    ],
    "final": "proxy",
    "auto_detect_interface": true,
    "override_android_vpn": true,
    "default_domain_resolver": "local"
  },
  "experimental": {
    "clash_api": {
      "external_controller": "127.0.0.1:9090",
      "external_ui": "ui",
      "external_ui_download_url": "https://ghfast.top/https://github.com/MetaCubeX/metacubexd/archive/refs/heads/gh-pages.zip",
      "external_ui_download_detour": "proxy",
      "default_mode": "rule"
    },
    "cache_file": {
      "enabled": true,
      "path": "cache.db",
      "cache_id": "singbox",
      "store_fakeip": true,
      "store_rdrc": true
    }
  }
};

        // ==========================================
        // 2. å·¥å…·å‡½æ•°
        // ==========================================
        function safeBase64Decode(str) {
            str = str.replace(/-/g, '+').replace(/_/g, '/');
            while (str.length % 4) { str += '='; }
            try { return decodeURIComponent(escape(window.atob(str))); } catch { return window.atob(str); }
        }

        function setStatus(text, type = 'normal') {
            const badge = document.getElementById('statusBadge');
            const txt = document.getElementById('statusText');
            txt.textContent = text;
            badge.className = 'format-badge ' + (type === 'success' ? 'active' : (type === 'error' ? 'error' : ''));
        }

        function processWsPath(pathStr) {
            if (!pathStr) return { path: '/' };
            const edMatch = pathStr.match(/[?&]ed=(\d+)/);
            if (edMatch) {
                const maxEarlyData = parseInt(edMatch[1], 10);
                let newPath = pathStr.replace(/[?&]ed=\d+/, '');
                if (newPath.endsWith('?')) newPath = newPath.slice(0, -1);
                if (newPath === '') newPath = '/';
                return {
                    path: newPath,
                    max_early_data: maxEarlyData,
                    early_data_header_name: "Sec-WebSocket-Protocol"
                };
            }
            return { path: pathStr };
        }

        // ==========================================
        // 3. è½¬æ¢é€»è¾‘ (Clash -> Singbox)
        // ==========================================
        function mapClashToSingbox(p) {
            if (!p || !p.type) return null;
            const node = { tag: p.name || 'Unnamed' };
            
            if(p.type) node.type = p.type;
            if(p.server) node.server = p.server;
            if(p.port) node.server_port = parseInt(p.port, 10);
            if(p.password) node.password = p.password;
            if(p.uuid) node.uuid = p.uuid;
            
            // Helper for Clash WS
            const applyClashWs = (target, opts, headers) => {
                const wsInfo = processWsPath(opts.path || '/');
                target.transport = {
                    type: 'ws',
                    path: wsInfo.path,
                    headers: headers || {}
                };
                if(wsInfo.max_early_data) {
                    target.transport.max_early_data = wsInfo.max_early_data;
                    target.transport.early_data_header_name = wsInfo.early_data_header_name;
                }
            };

            if (p.type === 'ss' || p.type === 'shadowsocks') {
                node.type = 'shadowsocks';
                node.method = p.cipher;
                if (p.plugin === 'v2ray-plugin' && p['plugin-opts']) {
                    const opts = p['plugin-opts'];
                    if (opts.mode === 'websocket') {
                        applyClashWs(node, opts, opts.headers || (opts.host ? {Host: opts.host} : {}));
                        if (opts.tls) {
                            node.tls = {
                                enabled: true,
                                server_name: opts.servername || opts.host || p.server,
                                insecure: opts['skip-cert-verify'] || false
                            };
                        }
                    }
                }
            } else if (p.type === 'vmess') {
                node.type = 'vmess';
                node.alter_id = p.alterId !== undefined ? parseInt(p.alterId) : 0;
                node.security = p.cipher || 'auto';
                
                if (p.network === 'ws') {
                    applyClashWs(node, p['ws-opts'] || {}, p['ws-opts']?.headers);
                } else if (p.network === 'grpc') {
                    node.transport = { type: 'grpc', service_name: p['grpc-opts']?.['grpc-service-name'] };
                }

                if (p.tls) {
                    node.tls = { 
                        enabled: true, 
                        server_name: p.servername || p.server, 
                        utls: { enabled: true, fingerprint: p['client-fingerprint'] || 'chrome' },
                        insecure: p['skip-cert-verify'] || false
                    };
                }
            } else if (p.type === 'vless') {
                node.flow = p.flow || '';
                if (p.tls) {
                    node.tls = { 
                        enabled: true, 
                        server_name: p.servername || p.server,
                        utls: { enabled: true, fingerprint: p['client-fingerprint'] || 'chrome' },
                        insecure: p['skip-cert-verify'] || false
                    };
                    if (p['reality-opts']) {
                        node.tls.reality = {
                            enabled: true,
                            public_key: p['reality-opts']['public-key'],
                            short_id: p['reality-opts']['short-id']
                        };
                    }
                }
                if (p.network === 'ws') {
                    applyClashWs(node, p['ws-opts'] || {}, p['ws-opts']?.headers);
                } else if (p.network === 'grpc') {
                    node.transport = { type: 'grpc', service_name: p['grpc-opts']?.['grpc-service-name'] };
                }
                if (node.flow === '') delete node.flow;
            } else if (p.type === 'trojan') {
                node.tls = {
                    enabled: true,
                    server_name: p.sni || p.servername || p.server,
                    utls: { enabled: true, fingerprint: p['client-fingerprint'] || 'chrome' },
                    insecure: p['skip-cert-verify'] || false
                };
                if(p.network === 'ws') {
                    applyClashWs(node, p['ws-opts'] || {}, p['ws-opts']?.headers);
                }
            } else if (p.type === 'hysteria2') {
                node.type = 'hysteria2';
                node.tls = {
                    enabled: true,
                    server_name: p.sni || p.server,
                    utls: { enabled: true, fingerprint: p['client-fingerprint'] || 'chrome' },
                    insecure: p['skip-cert-verify'] || false
                };
                if(p.obfs) {
                    node.obfs = { type: 'salamander', password: p['obfs-password'] };
                }
            }
            return node;
        }

        // ==========================================
        // 4. é“¾æ¥è§£æé€»è¾‘
        // ==========================================
        function parseURI(line) {
            line = line.trim();
            if (!line) return null;

            try {
                const protocols = ['vless://', 'vmess://', 'ss://', 'trojan://', 'hysteria2://'];
                let startIndex = -1;
                for (let p of protocols) {
                    startIndex = line.indexOf(p);
                    if (startIndex !== -1) break;
                }
                
                if (startIndex === -1) return null;
                
                let urlStr = line.substring(startIndex);
                let uriObj;
                try {
                    uriObj = new URL(urlStr);
                } catch(e) {
                    // Handle broken hash
                    const hashIndex = urlStr.indexOf('#');
                    if (hashIndex !== -1) {
                        const preHash = urlStr.substring(0, hashIndex);
                        const postHash = urlStr.substring(hashIndex + 1);
                        try {
                            uriObj = new URL(preHash);
                            uriObj.hash = '#' + encodeURIComponent(postHash);
                        } catch(ex) { return null; }
                    } else {
                        return null; 
                    }
                }

                const protocol = uriObj.protocol.replace(':', '');
                const params = Object.fromEntries(uriObj.searchParams);
                
                let tag = '';
                if (uriObj.hash) {
                    try { tag = decodeURIComponent(uriObj.hash.slice(1)); } 
                    catch { tag = uriObj.hash.slice(1); }
                }
                if (!tag && params.remarks) tag = decodeURIComponent(params.remarks);
                if (!tag) tag = 'Node';

                const node = {
                    tag: tag,
                    server: uriObj.hostname,
                    server_port: parseInt(uriObj.port, 10)
                };

                const applyWs = (targetNode, path, headers) => {
                    const wsInfo = processWsPath(path || '/');
                    targetNode.transport = { 
                        type: 'ws', 
                        path: wsInfo.path, 
                        headers: headers || {} 
                    };
                    if(wsInfo.max_early_data) {
                        targetNode.transport.max_early_data = wsInfo.max_early_data;
                        targetNode.transport.early_data_header_name = wsInfo.early_data_header_name;
                    }
                };

                if (protocol === 'vless') {
                    node.type = 'vless';
                    node.uuid = uriObj.username;
                    node.flow = params.flow || '';
                    if (node.flow === '') delete node.flow;

                    const isTls = params.security === 'tls' || params.security === 'reality' || params.tls === '1';
                    const isReality = params.security === 'reality';
                    
                    if (isTls) {
                        node.tls = {
                            enabled: true,
                            server_name: params.sni || params.peer || params.host || node.server,
                            utls: { enabled: true, fingerprint: params.fp || 'chrome' },
                            insecure: params.allowInsecure === '1'
                        };
                        if (isReality) {
                            node.tls.reality = {
                                enabled: true,
                                public_key: params.pbk,
                                short_id: params.sid || ''
                            };
                        }
                    }

                    const type = params.type || params.obfs;
                    if (type === 'ws' || type === 'websocket') {
                        applyWs(node, params.path, params.host ? {Host: params.host} : {});
                    } else if (type === 'grpc') {
                        node.transport = { type: 'grpc', service_name: params.serviceName || params.path || 'grpc' };
                    }

                } else if (protocol === 'vmess') {
                    if (!uriObj.username && urlStr.includes('vmess://')) {
                         const b64 = urlStr.replace('vmess://', '');
                         try {
                            const v = JSON.parse(safeBase64Decode(b64));
                            return mapClashToSingbox({
                                type: 'vmess', name: v.ps, server: v.add, port: v.port, uuid: v.id, alterId: v.aid,
                                cipher: v.scy || 'auto', network: v.net, tls: v.tls==='tls',
                                servername: v.sni || v.host, "ws-opts": {path: v.path, headers: {Host:v.host}},
                                "grpc-opts": {"grpc-service-name": v.path}
                            });
                         } catch(e) {}
                    }
                    
                    node.type = 'vmess';
                    node.uuid = uriObj.username;
                    node.alter_id = 0;
                    node.security = 'auto';

                    const type = params.obfs || params.type || 'tcp';
                    if (type === 'websocket' || type === 'ws') {
                        applyWs(node, params.path, params.obfsParam ? {Host: params.obfsParam} : {});
                    }
                    if (params.tls === '1') {
                        node.tls = { enabled: true, server_name: params.peer || params.obfsParam };
                    }

                } else if (protocol === 'trojan') {
                    node.type = 'trojan';
                    node.password = uriObj.username;
                    node.tls = {
                        enabled: true,
                        server_name: params.sni || params.peer || node.server,
                        utls: { enabled: true, fingerprint: 'chrome' }
                    };

                    const type = params.type || params.obfs;
                    const pluginStr = params.plugin || "";
                    
                    if (type === 'ws' || type === 'websocket') {
                        applyWs(node, params.path, params.host ? {Host: params.host} : {});
                    } else if (pluginStr.includes('obfs-local') && pluginStr.includes('websocket')) {
                        const pParts = pluginStr.split(';');
                        let wsPath = '/', wsHost = '';
                        pParts.forEach(p => {
                             if(p.includes('obfs-uri')) wsPath = p.split('=')[1];
                             if(p.includes('obfs-host')) wsHost = p.split('=')[1];
                        });
                        applyWs(node, wsPath, wsHost ? {Host: wsHost} : {});
                    }

                } else if (protocol === 'ss') {
                    let userInfo = uriObj.username;
                    if (!userInfo.includes(':')) {
                        const decoded = safeBase64Decode(userInfo);
                        if (decoded.includes(':')) userInfo = decoded;
                    }
                    let [method, password] = userInfo.split(':');
                    if (userInfo.includes('@')) {
                         const parts = userInfo.split('@');
                         const creds = parts[0].split(':');
                         method = creds[0];
                         password = creds[1];
                    }

                    node.type = 'shadowsocks';
                    node.method = method;
                    node.password = password;

                    const pluginStr = params.plugin || params['v2ray-plugin'] || "";
                    
                    if (pluginStr.includes('v2ray-plugin') || pluginStr.includes('obfs')) {
                         let opts = {};
                         if (!pluginStr.startsWith('{')) {
                             const parts = pluginStr.split(';');
                             parts.forEach(part => {
                                 const [k, v] = part.split('=');
                                 if(k) opts[k] = v || true;
                             });
                         }
                         
                         if (opts.mode === 'websocket' || opts.obfs === 'websocket') {
                             const host = opts.host || opts['obfs-host'];
                             applyWs(node, opts.path, host ? {Host: host} : {});
                             
                             if (opts.tls === true || opts.tls === 'true') {
                                 node.tls = {
                                     enabled: true,
                                     server_name: host || node.server
                                 };
                             }
                         }
                    }
                }
                return node.type ? node : null;
            } catch (e) { return null; }
        }

        // ==========================================
        // 5. ä¸»è½¬æ¢é€»è¾‘
        // ==========================================
        function convert() {
            const rawInput = document.getElementById('inputArea').value.trim();
            if (!rawInput) return;

            setStatus('æ­£åœ¨è§£ææ··åˆå†…å®¹...');
            let nodes = [];
            
            let input = rawInput;
            // ç®€å•åˆ¤æ–­æ˜¯å¦ base64
            if (!input.includes('://') && !input.includes('outbounds') && !input.includes('proxies:')) {
                const decoded = safeBase64Decode(input);
                if (decoded && (decoded.includes('://') || decoded.includes('proxies:'))) {
                    input = decoded;
                }
            }

            // å°è¯• YAML (Clash)
            const yamlLines = [];
            const lines = input.split(/\r?\n/);
            lines.forEach(line => {
                const trimmed = line.trim();
                if (trimmed.startsWith('- {') && trimmed.includes('name:') && trimmed.includes('type:')) {
                    yamlLines.push(trimmed);
                }
            });

            if (yamlLines.length > 0) {
                try {
                    const fakeYaml = "proxies:\n" + yamlLines.join("\n");
                    const parsed = jsyaml.load(fakeYaml);
                    if (parsed && parsed.proxies) {
                        parsed.proxies.forEach(p => {
                            const node = mapClashToSingbox(p);
                            if (node) nodes.push(node);
                        });
                    }
                } catch (e) { console.warn("YAML fragment parse error", e); }
            }

            // å°è¯• JSON (Sing-boxç‰‡æ®µ)
            if (input.includes('"outbounds"')) {
                try {
                    let jsonParsed = false;
                    try {
                        const j = JSON.parse(input);
                        if(j.outbounds) {
                            j.outbounds.forEach(o => {
                                if(o.type !== 'selector' && o.type !== 'urltest' && o.type!=='direct') nodes.push(o);
                            });
                            jsonParsed = true;
                        }
                    } catch(e) {}
                    if (!jsonParsed) {
                        const match = input.match(/"outbounds"\s*:\s*(\[[\s\S]*?\])/);
                        if (match) {
                            const arrStr = match[1];
                            const lastBracket = arrStr.lastIndexOf(']');
                            const validJsonArr = arrStr.substring(0, lastBracket+1);
                            const arr = JSON.parse(validJsonArr);
                            arr.forEach(o => {
                                if(o.type !== 'selector' && o.type !== 'urltest' && o.type!=='direct') nodes.push(o);
                            });
                        }
                    }
                } catch (e) { console.warn("JSON fragment parse error", e); }
            }

            // å°è¯• URI
            lines.forEach(line => {
                if (line.trim().startsWith('- {')) return;
                const node = parseURI(line);
                if (node) nodes.push(node);
            });

            if (nodes.length === 0) {
                setStatus('æœªæ‰¾åˆ°æœ‰æ•ˆèŠ‚ç‚¹', 'error');
                return;
            }

            // å»é‡ä¸æ ‡ç­¾é‡å‘½å
            const uniqueNodes = [];
            const tagCounts = {};

            nodes.forEach(node => {
                let tag = node.tag || 'node';
                if (tagCounts[tag]) {
                    tagCounts[tag]++;
                    tag = `${tag} ${tagCounts[tag]}`;
                } else {
                    tagCounts[tag] = 1;
                }
                node.tag = tag;
                uniqueNodes.push(node);
            });

            // å¤åˆ¶æ¨¡æ¿
            const finalConfig = JSON.parse(JSON.stringify(TEMPLATE));
            const nodeTags = uniqueNodes.map(n => n.tag);
            
            // 1. æ›´æ–° 'proxy' é€‰æ‹©å™¨ (æ·»åŠ æ‰€æœ‰èŠ‚ç‚¹ + auto + direct)
            // æ³¨æ„ï¼šæ–°æ¨¡æ¿ä¸­çš„ç›´è¿æ ‡ç­¾æ˜¯å°å†™ "direct"
            const proxySelector = finalConfig.outbounds.find(o => o.tag === 'proxy');
            if (proxySelector && proxySelector.type === 'selector') {
                proxySelector.outbounds = ["auto", ...nodeTags, "direct"];
            }
            
            // 2. æ›´æ–° 'auto' urltest (æ·»åŠ æ‰€æœ‰èŠ‚ç‚¹)
            const autoUrlTest = finalConfig.outbounds.find(o => o.tag === 'auto');
            if (autoUrlTest && autoUrlTest.type === 'urltest') {
                autoUrlTest.outbounds = nodeTags;
            }

            // 3. å°†æ–°èŠ‚ç‚¹æ·»åŠ åˆ° outbounds åˆ—è¡¨æœ«å°¾
            finalConfig.outbounds.push(...uniqueNodes);

            document.getElementById('outputArea').value = JSON.stringify(finalConfig, null, 2);
            setStatus(`è½¬æ¢æˆåŠŸ (æ¥æºæ··åˆ)`, 'success');
            document.getElementById('statsText').textContent = `èŠ‚ç‚¹æ•°: ${uniqueNodes.length}`;
        }

        function clearInput() {
            document.getElementById('inputArea').value = '';
            document.getElementById('outputArea').value = '';
            setStatus('å·²æ¸…ç©º');
            document.getElementById('statsText').textContent = 'èŠ‚ç‚¹æ•°: 0';
        }

        function copyResult() {
            const output = document.getElementById('outputArea');
            if (output.value) {
                output.select();
                document.execCommand('copy');
                setStatus('å·²å¤åˆ¶', 'success');
            }
        }
    </script>
</body>
</html>
