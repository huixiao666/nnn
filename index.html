<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sing-box å…¨åè®®é…ç½®ç”Ÿæˆå™¨ (1.13.0+)</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --text-color: #d4d4d4;
            --accent-color: #007acc;
            --secondary-bg: #252526;
            --border-color: #3e3e42;
            --success-color: #4caf50;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 15px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 1;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.4rem;
            text-align: center;
            color: #fff;
        }

        /* å¸ƒå±€è°ƒæ•´ï¼šç§»åŠ¨ç«¯ä¼˜å…ˆï¼ŒPCç«¯å¹¶æ’ */
        .panels {
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 1;
            min-height: 0;
        }

        @media (min-width: 768px) {
            .panels {
                flex-direction: row;
            }
        }

        .panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: var(--secondary-bg);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid var(--border-color);
            min-height: 250px;
        }

        .panel-header {
            font-weight: bold;
            font-size: 0.9rem;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        textarea {
            flex: 1;
            background-color: #1e1e1e;
            color: #9cdcfe;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            resize: none;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 11px;
            outline: none;
            white-space: pre;
            overflow-x: auto;
        }

        textarea:focus {
            border-color: var(--accent-color);
        }

        .btn-group {
            display: flex;
            gap: 10px;
        }

        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        button:hover {
            background-color: #005f9e;
        }

        button.secondary {
            background-color: #3e3e42;
        }
        
        button.secondary:hover {
            background-color: #505055;
        }

        button.main-action {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            font-weight: bold;
            background-color: var(--success-color);
            margin-top: 5px;
        }
        
        button.main-action:hover {
            background-color: #43a047;
        }
        
        .status-bar {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
            text-align: center;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Sing-box å…¨åè®®é…ç½®ç”Ÿæˆå™¨</h1>
        
        <div class="panels">
            <!-- è¾“å…¥é¢æ¿ -->
            <div class="panel">
                <div class="panel-header">
                    <span>èŠ‚ç‚¹é“¾æ¥ (æ”¯æŒ vless, vmess, trojan, ss, hy2, tuic)</span>
                    <button class="secondary" onclick="clearInput()">æ¸…ç©º</button>
                </div>
                <textarea id="inputNodes" placeholder="åœ¨æ­¤ç²˜è´´åˆ†äº«é“¾æ¥ï¼Œæ¯è¡Œä¸€ä¸ª...&#10;vmess://...&#10;vless://...&#10;ss://...&#10;trojan://...&#10;hy2://..."></textarea>
            </div>

            <!-- è¾“å‡ºé¢æ¿ -->
            <div class="panel">
                <div class="panel-header">
                    <span>Config.json ç»“æœ</span>
                    <button class="secondary" onclick="copyResult()">å¤åˆ¶é…ç½®</button>
                </div>
                <textarea id="outputConfig" readonly placeholder="ç‚¹å‡»ä¸‹æ–¹ç»¿è‰²æŒ‰é’®ç”Ÿæˆé…ç½®..."></textarea>
            </div>
        </div>

        <button class="main-action" onclick="generateConfig()">ğŸš€ è‡ªåŠ¨è½¬æ¢å¹¶ç”Ÿæˆé…ç½®</button>
        <div class="status-bar" id="statusBar">ç­‰å¾…è¾“å…¥...</div>
    </div>

    <script>
        // ==========================================
        // 1. åŸºç¡€æ¨¡æ¿ (åŸºäº 1.txt)
        // ==========================================
        const baseTemplate = {
            "log": { "level": "warn", "timestamp": true },
            "dns": {
                "servers": [
                    { "tag": "dns_local", "type": "udp", "server": "223.5.5.5" },
                    { "tag": "dns_google", "type": "udp", "server": "8.8.8.8", "detour": "proxy" },
                    { "tag": "dns_fakeip", "type": "fakeip", "inet4_range": "198.18.0.0/15", "inet6_range": "fc00::/18" }
                ],
                "rules": [
                    { "clash_mode": "Direct", "server": "dns_local" },
                    { "clash_mode": "Global", "server": "dns_fakeip" },
                    { "rule_set": "geosite_cn", "server": "dns_local" },
                    { "rule_set": ["geosite_google", "geosite_youtube", "geosite_netflix", "geosite_telegram", "geosite_geolocation_non_cn"], "server": "dns_fakeip" }
                ],
                "final": "dns_google",
                "independent_cache": true
            },
            "inbounds": [
                {
                    "type": "tun", "tag": "tun-in", "address": ["172.19.0.1/30", "fd00::1/126"], "mtu": 1500,
                    "auto_route": true, "strict_route": true, "stack": "mixed", "sniff": true, "sniff_override_destination": false,
                    "platform": { "http_proxy": { "enabled": true, "server": "127.0.0.1", "server_port": 7890 } }
                },
                { "type": "mixed", "tag": "mixed-in", "listen": "127.0.0.1", "listen_port": 7890, "sniff": true, "sniff_override_destination": false }
            ],
            "outbounds": [], 
            "route": {
                "rules": [
                    { "port": 853, "action": "reject" },
                    { "protocol": "quic", "action": "reject" },
                    { "protocol": "dns", "action": "hijack-dns" },
                    { "port": 53, "action": "hijack-dns" },
                    { "rule_set": "geosite_telegram", "action": "route", "outbound": "telegram" },
                    { "rule_set": "geoip_telegram", "action": "route", "outbound": "telegram" },
                    { "action": "sniff", "sniffer": ["http", "tls", "quic", "dns"], "timeout": "500ms" },
                    { "clash_mode": "Direct", "action": "route", "outbound": "DIRECT" },
                    { "clash_mode": "Global", "action": "route", "outbound": "GLOBAL" },
                    { "ip_is_private": true, "action": "route", "outbound": "DIRECT" },
                    { "rule_set": "geosite_cn", "action": "route", "outbound": "DIRECT" },
                    { "rule_set": "geosite_bilibili", "action": "route", "outbound": "bilibili" },
                    { "rule_set": "geosite_apple", "action": "route", "outbound": "apple" },
                    { "rule_set": ["geosite_ads", "geosite_adguard"], "action": "reject" },
                    { "rule_set": "geosite_google", "action": "route", "outbound": "google" },
                    { "rule_set": "geosite_netflix", "action": "route", "outbound": "netflix" },
                    { "rule_set": "geosite_youtube", "action": "route", "outbound": "youtube" },
                    { "rule_set": "geosite_openai", "action": "route", "outbound": "openai" },
                    { "rule_set": "geosite_bahamut", "action": "route", "outbound": "bahamut" },
                    { "rule_set": "geoip_netflix", "action": "route", "outbound": "netflix" },
                    { "rule_set": "geosite_geolocation_non_cn", "action": "route", "outbound": "proxy" },
                    { "rule_set": "geoip_google", "action": "route", "outbound": "google" },
                    { "rule_set": "geoip_cn", "action": "route", "outbound": "cn" }
                ],
                "rule_set": [
                    { "tag": "geosite_ads", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/category-ads-all.srs", "download_detour": "DIRECT" },
                    { "tag": "geosite_adguard", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblocksingbox.srs", "download_detour": "DIRECT" },
                    { "tag": "geosite_apple", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/apple.srs", "download_detour": "DIRECT" },
                    { "tag": "geosite_bahamut", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/bahamut.srs", "download_detour": "DIRECT" },
                    { "tag": "geosite_bilibili", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/bilibili.srs", "download_detour": "DIRECT" },
                    { "tag": "geosite_cn", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/cn.srs", "download_detour": "DIRECT" },
                    { "tag": "geosite_google", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/google.srs", "download_detour": "DIRECT" },
                    { "tag": "geosite_netflix", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/netflix.srs", "download_detour": "DIRECT" },
                    { "tag": "geosite_openai", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/openai.srs", "download_detour": "DIRECT" },
                    { "tag": "geosite_telegram", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/telegram.srs", "download_detour": "DIRECT" },
                    { "tag": "geosite_youtube", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/youtube.srs", "download_detour": "DIRECT" },
                    { "tag": "geosite_geolocation_non_cn", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/geolocation-!cn.srs", "download_detour": "DIRECT" },
                    { "tag": "geoip_cn", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geoip/cn.srs", "download_detour": "DIRECT" },
                    { "tag": "geoip_google", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geoip/google.srs", "download_detour": "DIRECT" },
                    { "tag": "geoip_netflix", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geoip/netflix.srs", "download_detour": "DIRECT" },
                    { "tag": "geoip_telegram", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geoip/telegram.srs", "download_detour": "DIRECT" }
                ],
                "final": "proxy",
                "auto_detect_interface": true,
                "override_android_vpn": true,
                "default_domain_resolver": "dns_local"
            },
            "experimental": {
                "cache_file": { "enabled": true, "path": "cache.db", "cache_id": "singbox", "store_fakeip": true, "store_rdrc": true },
                "clash_api": {
                    "external_controller": "127.0.0.1:9090",
                    "external_ui": "ui",
                    "external_ui_download_url": "https://ghfast.top/https://github.com/MetaCubeX/metacubexd/archive/refs/heads/gh-pages.zip",
                    "external_ui_download_detour": "DIRECT",
                    "default_mode": "rule"
                }
            }
        };

        // ==========================================
        // 2. å·¥å…·å‡½æ•°
        // ==========================================
        function safeBase64Decode(str) {
            str = str.replace(/-/g, '+').replace(/_/g, '/');
            while (str.length % 4) { str += '='; }
            try {
                return decodeURIComponent(escape(window.atob(str)));
            } catch (e) {
                return window.atob(str);
            }
        }

        function getUrlParam(url, key) {
            return url.searchParams.get(key) || "";
        }

        // ==========================================
        // 3. å¤šåè®®è§£æå™¨
        // ==========================================
        
        // --- 3.1 VMess è§£æ ---
        function parseVmess(link) {
            try {
                const b64 = link.replace("vmess://", "");
                const jsonStr = safeBase64Decode(b64);
                const config = JSON.parse(jsonStr);
                
                const node = {
                    type: "vmess",
                    tag: config.ps || "VMess Node",
                    server: config.add,
                    server_port: parseInt(config.port),
                    uuid: config.id,
                    alter_id: parseInt(config.aid || 0),
                    security: config.scy || "auto",
                    tls: { enabled: false },
                    packet_encoding: "xudp"
                };

                // Transport Mapping
                if (config.net === "ws") {
                    node.transport = {
                        type: "ws",
                        path: config.path || "/",
                        headers: {}
                    };
                    if (config.host) node.transport.headers.Host = config.host;
                } else if (config.net === "grpc") {
                    node.transport = {
                        type: "grpc",
                        service_name: config.path || "grpc" // vmess jsonä¸­ grpc serviceNameé€šå¸¸åœ¨pathå­—æ®µ
                    };
                }

                // TLS
                if (config.tls === "tls") {
                    node.tls.enabled = true;
                    node.tls.server_name = config.sni || config.host || "";
                    node.tls.utls = { enabled: true, fingerprint: "chrome" };
                }
                
                return node;
            } catch(e) { console.error("VMess Parse Error", e); return null; }
        }

        // --- 3.2 Shadowsocks è§£æ ---
        function parseSs(link) {
            try {
                // æ”¯æŒ ss://user:pass@host:port#tag æˆ– ss://base64#tag
                let url;
                if (link.includes("@")) {
                    url = new URL(link);
                } else {
                    // Legacy base64 format
                    const raw = link.replace("ss://", "").split("#");
                    const decoded = safeBase64Decode(raw[0]);
                    const tag = raw[1] ? decodeURIComponent(raw[1]) : "SS Node";
                    // decoded pattern: method:pass@host:port
                    const lastAt = decoded.lastIndexOf("@");
                    const userPass = decoded.substring(0, lastAt);
                    const serverPort = decoded.substring(lastAt + 1);
                    url = new URL(`ss://${userPass}@${serverPort}#${tag}`);
                }

                const userPass =  decodeURIComponent(url.username).split(":");
                // æŸäº›é“¾æ¥æ ¼å¼æ˜¯ ss://base64(method:pass)@host:port
                let method = userPass[0];
                let password = userPass[1];

                if (!password && !url.password) {
                     // å°è¯•è§£base64 userinfo
                     const decodedAuth = safeBase64Decode(url.username).split(":");
                     method = decodedAuth[0];
                     password = decodedAuth[1];
                } else if (url.password) {
                    password = url.password;
                }

                const node = {
                    type: "shadowsocks",
                    tag: decodeURIComponent(url.hash).replace(/^#/, '') || "SS Node",
                    server: url.hostname,
                    server_port: parseInt(url.port),
                    method: method,
                    password: password
                };
                
                // ç®€æ˜“æ’ä»¶æ”¯æŒ (Obfs) - Singboxå†…ç½®æ”¯æŒä¸å¤šï¼Œè¿™é‡Œä»…ä½œåŸºç¡€å…¼å®¹
                const plugin = url.searchParams.get("plugin");
                if (plugin && plugin.includes("obfs")) {
                     // ç®€å•å¤„ç† simple-obfs è½¬æ¢ä¸º http/tls transport å¹¶ä¸å®Œç¾ï¼Œ
                     // singbox æ¨èä½¿ç”¨ shadow-tls æˆ– æ ‡å‡† transportã€‚
                     // è¿™é‡Œæš‚ä¸æ·±å…¥è½¬æ¢å¤æ‚æ’ä»¶ï¼Œä»…ä¿ç•™åŸºç¡€SSã€‚
                }

                return node;
            } catch(e) { console.error("SS Parse Error", e); return null; }
        }

        // --- 3.3 Trojan / VLESS / Hysteria2 / TUIC é€šç”¨URLè§£æ ---
        function parseUrlCommon(link, protocol) {
            try {
                const url = new URL(link);
                const tag = decodeURIComponent(url.hash).replace(/^#/, '') || `${protocol} Node`;
                
                const node = {
                    type: protocol,
                    tag: tag,
                    server: url.hostname,
                    server_port: parseInt(url.port) || 443,
                    tls: { enabled: false }
                };

                // Auth
                if (protocol === "trojan" || protocol === "hysteria2") {
                    node.password = decodeURIComponent(url.username);
                } else if (protocol === "tuic") {
                    node.uuid = decodeURIComponent(url.username);
                    node.password = decodeURIComponent(url.password);
                } else if (protocol === "vless") {
                    node.uuid = decodeURIComponent(url.username);
                    node.flow = url.searchParams.get("flow") || "";
                    node.packet_encoding = "xudp";
                }

                // Security / TLS / SNI
                const sni = url.searchParams.get("sni") || url.searchParams.get("peer") || url.searchParams.get("host");
                const security = url.searchParams.get("security"); // vless specific
                const insecure = url.searchParams.get("allowInsecure") === "1";
                const alpn = url.searchParams.get("alpn");
                const fp = url.searchParams.get("fp");

                // Determine TLS
                if (protocol === "hysteria2" || protocol === "tuic" || protocol === "trojan" || security === "tls" || security === "reality") {
                    node.tls.enabled = true;
                    if (sni) node.tls.server_name = sni;
                    if (insecure) node.tls.insecure = true;
                    if (alpn) node.tls.alpn = alpn.split(",");
                    
                    node.tls.utls = { enabled: true, fingerprint: fp || "chrome" };
                    
                    // Reality
                    if (security === "reality" || (protocol === "vless" && url.searchParams.get("pbk"))) {
                        node.tls.reality = {
                            enabled: true,
                            public_key: url.searchParams.get("pbk"),
                            short_id: url.searchParams.get("sid") || ""
                        };
                    }
                }

                // Transport (WS/GRPC/HTTPUpgrade)
                const type = url.searchParams.get("type");
                const path = decodeURIComponent(url.searchParams.get("path") || "/");
                const host = url.searchParams.get("host");
                const serviceName = url.searchParams.get("serviceName");

                if (type === "ws") {
                    node.transport = { type: "ws", path: path, headers: {} };
                    if (host) node.transport.headers.Host = host;
                } else if (type === "grpc") {
                    node.transport = { type: "grpc", service_name: serviceName || path };
                } else if (type === "http") {
                     node.transport = { type: "http", path: path, headers: {} };
                     if (host) node.transport.headers.Host = host;
                }

                // Hysteria2 Obfs
                if (protocol === "hysteria2") {
                    const obfs = url.searchParams.get("obfs");
                    if (obfs && obfs !== "none") {
                        node.obfs = { type: obfs, password: url.searchParams.get("obfs-password") };
                    }
                }
                
                // Tuic Congestion
                if (protocol === "tuic") {
                    const cc = url.searchParams.get("congestion_control");
                    if (cc) node.congestion_control = cc;
                }

                return node;
            } catch(e) { console.error(`${protocol} Parse Error`, e); return null; }
        }

        // --- 3.4 è°ƒåº¦ä¸­å¿ƒ ---
        function parseNode(line) {
            line = line.trim();
            if (!line) return null;

            if (line.startsWith("vmess://")) return parseVmess(line);
            if (line.startsWith("ss://")) return parseSs(line);
            if (line.startsWith("trojan://")) return parseUrlCommon(line, "trojan");
            if (line.startsWith("vless://")) return parseUrlCommon(line, "vless");
            if (line.startsWith("hy2://") || line.startsWith("hysteria2://")) return parseUrlCommon(line, "hysteria2");
            if (line.startsWith("tuic://")) return parseUrlCommon(line, "tuic");
            if (line.startsWith("socks5://") || line.startsWith("socks://")) {
                 // ç®€å•å¤„ç†socks
                 try {
                     const u = new URL(line);
                     return {
                         type: "socks",
                         tag: decodeURIComponent(u.hash).replace(/^#/, '') || "Socks5",
                         server: u.hostname,
                         server_port: parseInt(u.port),
                         username: u.username,
                         password: u.password
                     };
                 } catch(e) { return null; }
            }
            if (line.startsWith("http://") && line.includes("@")) {
                 // ç®€å•å¤„ç†http proxy
                 try {
                     const u = new URL(line);
                     return {
                         type: "http",
                         tag: decodeURIComponent(u.hash).replace(/^#/, '') || "HTTP",
                         server: u.hostname,
                         server_port: parseInt(u.port),
                         username: u.username,
                         password: u.password
                     };
                 } catch(e) { return null; }
            }

            return null;
        }

        // ==========================================
        // 4. ç”Ÿæˆé€»è¾‘
        // ==========================================
        function getStaticOutbounds(proxyTags) {
            const allProxies = proxyTags.length > 0 ? proxyTags : ["DIRECT"];
            return [
                { "type": "direct", "tag": "DIRECT" },
                {
                    "type": "selector",
                    "tag": "proxy",
                    "outbounds": ["auto", ...proxyTags, "DIRECT"],
                    "default": "auto",
                    "interrupt_exist_connections": false
                },
                {
                    "type": "urltest",
                    "tag": "auto",
                    "outbounds": allProxies,
                    "url": "https://www.gstatic.com/generate_204",
                    "interval": "10m",
                    "tolerance": 50,
                    "idle_timeout": "30m",
                    "interrupt_exist_connections": false
                },
                // åˆ›å»ºå„åŠŸèƒ½ç»„
                ...["google", "apple", "telegram", "bilibili", "netflix", "bahamut", "youtube", "openai", "GLOBAL", "cn", "final"].map(tag => ({
                    "type": "selector",
                    "tag": tag,
                    "outbounds": tag === "apple" || tag === "bilibili" || tag === "cn" ? ["DIRECT", "proxy"] : (tag === "final" ? ["proxy", "DIRECT"] : ["proxy", "auto", "DIRECT"]),
                    "default": tag === "apple" || tag === "bilibili" || tag === "cn" || tag === "GLOBAL" ? "DIRECT" : "proxy"
                }))
            ];
        }

        function generateConfig() {
            const input = document.getElementById("inputNodes").value;
            const lines = input.split('\n');
            const newNodes = [];
            const newTags = [];
            const tagCounts = {};

            const status = document.getElementById("statusBar");
            status.textContent = "æ­£åœ¨è§£æ...";

            lines.forEach(line => {
                const node = parseNode(line);
                if (node) {
                    // å¤„ç†é‡åTag
                    let baseTag = node.tag;
                    if (tagCounts[baseTag]) {
                        tagCounts[baseTag]++;
                        node.tag = `${baseTag} (${tagCounts[baseTag]})`;
                    } else {
                        tagCounts[baseTag] = 1;
                    }
                    
                    newNodes.push(node);
                    newTags.push(node.tag);
                }
            });

            if (newNodes.length === 0) {
                status.textContent = "âŒ æœªæ£€æµ‹åˆ°æœ‰æ•ˆèŠ‚ç‚¹é“¾æ¥";
                alert("æœªæ£€æµ‹åˆ°æœ‰æ•ˆèŠ‚ç‚¹ï¼è¯·æ£€æŸ¥æ ¼å¼æ˜¯å¦æ­£ç¡®ã€‚");
                return;
            }

            const finalConfig = JSON.parse(JSON.stringify(baseTemplate));
            const staticOutbounds = getStaticOutbounds(newTags);
            
            // ç»„è£… Outbounds: é™æ€ç­–ç•¥ç»„ + åŠ¨æ€èŠ‚ç‚¹
            finalConfig.outbounds = [...staticOutbounds, ...newNodes];

            const jsonStr = JSON.stringify(finalConfig, null, 2);
            document.getElementById("outputConfig").value = jsonStr;
            status.textContent = `âœ… æˆåŠŸç”Ÿæˆ ${newNodes.length} ä¸ªèŠ‚ç‚¹é…ç½®`;
        }

        function clearInput() {
            document.getElementById("inputNodes").value = "";
            document.getElementById("outputConfig").value = "";
            document.getElementById("statusBar").textContent = "ç­‰å¾…è¾“å…¥...";
        }

        function copyResult() {
            const output = document.getElementById("outputConfig");
            if (!output.value) return;
            output.select();
            document.execCommand("copy");
            document.getElementById("statusBar").textContent = "ğŸ“‹ å·²å¤åˆ¶åˆ°å‰ªè´´æ¿";
        }
    </script>
</body>
</html>
