<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sing-box 终极转换器 (支持 SubStore/QX/Clash)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <style>
        :root { --bg: #111827; --card: #1f2937; --text: #f3f4f6; --text-dim: #9ca3af; --accent: #6366f1; --border: #374151; --success: #10b981; }
        body { font-family: system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text); margin: 0; height: 100vh; display: flex; flex-direction: column; }
        header { padding: 0 20px; height: 60px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; background: rgba(17, 24, 39, 0.9); backdrop-filter: blur(10px); }
        h1 { margin: 0; font-size: 1.1rem; font-weight: 600; display: flex; align-items: center; gap: 8px; }
        .badge { font-size: 0.7rem; background: var(--accent); padding: 2px 6px; border-radius: 4px; color: white; }
        .main { flex: 1; display: flex; gap: 15px; padding: 15px; overflow: hidden; }
        .pane { flex: 1; display: flex; flex-direction: column; background: var(--card); border: 1px solid var(--border); border-radius: 8px; }
        .pane-head { padding: 10px 15px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; font-size: 0.85rem; color: var(--text-dim); background: rgba(0,0,0,0.2); }
        textarea { flex: 1; background: transparent; border: none; color: var(--text); padding: 15px; resize: none; outline: none; font-family: Consolas, monospace; font-size: 12px; line-height: 1.4; }
        button { background: var(--border); color: var(--text); border: none; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; transition: 0.2s; }
        button:hover { background: var(--accent); color: white; }
        button.primary { background: var(--accent); color: white; }
        .status-bar { padding: 0 20px; height: 32px; border-top: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; font-size: 0.75rem; color: var(--text-dim); background: var(--card); }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text-dim); margin-right: 6px; display: inline-block; }
        .dot.active { background: var(--success); box-shadow: 0 0 8px var(--success); }
        @media (max-width: 768px) { .main { flex-direction: column; } }
    </style>
</head>
<body>

<header>
    <h1>Sing-box Pro <span class="badge">SubStore 增强版</span></h1>
    <div style="display: flex; gap: 10px; align-items: center;">
        <label style="font-size: 0.8rem; cursor: pointer; color: var(--text-dim);">
            <input type="checkbox" id="autoMode" checked> 自动转换
        </label>
        <button class="primary" onclick="convert()">转换</button>
    </div>
</header>

<div class="main">
    <div class="pane">
        <div class="pane-head">
            <span>输入 (支持 SubStore / QX / Clash / Surge / Base64)</span>
            <button onclick="clearInput()">清空</button>
        </div>
        <textarea id="input" placeholder="请粘贴 SubStore 导出的内容。支持格式：&#10;1. Quantumult X 格式 (vmess=..., tag=...)&#10;2. Clash YAML&#10;3. Sing-box/Xray JSON&#10;4. Surge [Proxy] 列表&#10;5. Base64 乱码订阅串"></textarea>
    </div>
    <div class="pane">
        <div class="pane-head">
            <span>输出 (Sing-box 1.13+)</span>
            <button onclick="copyResult()">复制配置</button>
        </div>
        <textarea id="output" readonly placeholder="配置将在此生成..."></textarea>
    </div>
</div>

<div class="status-bar">
    <div style="display: flex; align-items: center;"><span class="dot" id="statusDot"></span><span id="statusMsg">就绪</span></div>
    <span id="nodeCount">节点: 0</span>
</div>

<script>
// =========================================
// 1. 核心模板 (Sing-box 1.13+ Tun/FakeIP)
// =========================================
const TEMPLATE = {
  "log": { "level": "warn", "timestamp": true },
  "dns": {
    "servers": [
      { "tag": "dns_local", "type": "udp", "server": "223.5.5.5" },
      { "tag": "dns_google", "type": "udp", "server": "8.8.8.8", "detour": "proxy" },
      { "tag": "dns_fakeip", "type": "fakeip", "inet4_range": "198.18.0.0/15", "inet6_range": "fc00::/18" }
    ],
    "rules": [
      { "clash_mode": "Direct", "server": "dns_local" },
      { "clash_mode": "Global", "server": "dns_fakeip" },
      { "rule_set": "geosite_cn", "server": "dns_local" },
      { "rule_set": ["geosite_google", "geosite_youtube", "geosite_netflix", "geosite_telegram", "geosite_geolocation_non_cn"], "server": "dns_fakeip" }
    ],
    "final": "dns_google",
    "independent_cache": true
  },
  "inbounds": [
    {
      "type": "tun", "tag": "tun-in", "address": ["172.19.0.1/30", "fd00::1/126"], "mtu": 1500,
      "auto_route": true, "strict_route": true, "stack": "mixed",
      "sniff": true, "sniff_override_destination": false,
      "platform": { "http_proxy": { "enabled": true, "server": "127.0.0.1", "server_port": 7890 } }
    },
    { "type": "mixed", "tag": "mixed-in", "listen": "127.0.0.1", "listen_port": 7890, "sniff": true }
  ],
  "outbounds": [],
  "route": {
    "rules": [
      { "port": 853, "action": "reject" },
      { "protocol": "quic", "action": "reject" },
      { "protocol": "dns", "action": "hijack-dns" },
      { "port": 53, "action": "hijack-dns" },
      { "rule_set": "geosite_telegram", "action": "route", "outbound": "telegram" },
      { "rule_set": "geoip_telegram", "action": "route", "outbound": "telegram" },
      { "action": "sniff", "sniffer": ["http", "tls", "quic", "dns"], "timeout": "500ms" },
      { "clash_mode": "Direct", "action": "route", "outbound": "DIRECT" },
      { "clash_mode": "Global", "action": "route", "outbound": "GLOBAL" },
      { "ip_is_private": true, "action": "route", "outbound": "DIRECT" },
      { "rule_set": "geosite_cn", "action": "route", "outbound": "DIRECT" },
      { "rule_set": "geosite_bilibili", "action": "route", "outbound": "bilibili" },
      { "rule_set": "geosite_apple", "action": "route", "outbound": "apple" },
      { "rule_set": ["geosite_ads", "geosite_adguard"], "action": "reject" },
      { "rule_set": "geosite_google", "action": "route", "outbound": "google" },
      { "rule_set": "geosite_netflix", "action": "route", "outbound": "netflix" },
      { "rule_set": "geosite_youtube", "action": "route", "outbound": "youtube" },
      { "rule_set": "geosite_openai", "action": "route", "outbound": "openai" },
      { "rule_set": "geosite_bahamut", "action": "route", "outbound": "bahamut" },
      { "rule_set": "geoip_netflix", "action": "route", "outbound": "netflix" },
      { "rule_set": "geosite_geolocation_non_cn", "action": "route", "outbound": "proxy" },
      { "rule_set": "geoip_google", "action": "route", "outbound": "google" },
      { "rule_set": "geoip_cn", "action": "route", "outbound": "cn" }
    ],
    "rule_set": [
      { "tag": "geosite_ads", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/category-ads-all.srs", "download_detour": "DIRECT" },
      { "tag": "geosite_adguard", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblocksingbox.srs", "download_detour": "DIRECT" },
      { "tag": "geosite_apple", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/apple.srs", "download_detour": "DIRECT" },
      { "tag": "geosite_bahamut", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/bahamut.srs", "download_detour": "DIRECT" },
      { "tag": "geosite_bilibili", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/bilibili.srs", "download_detour": "DIRECT" },
      { "tag": "geosite_cn", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/cn.srs", "download_detour": "DIRECT" },
      { "tag": "geosite_google", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/google.srs", "download_detour": "DIRECT" },
      { "tag": "geosite_netflix", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/netflix.srs", "download_detour": "DIRECT" },
      { "tag": "geosite_openai", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/openai.srs", "download_detour": "DIRECT" },
      { "tag": "geosite_telegram", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/telegram.srs", "download_detour": "DIRECT" },
      { "tag": "geosite_youtube", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/youtube.srs", "download_detour": "DIRECT" },
      { "tag": "geosite_geolocation_non_cn", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/geolocation-!cn.srs", "download_detour": "DIRECT" },
      { "tag": "geoip_cn", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geoip/cn.srs", "download_detour": "DIRECT" },
      { "tag": "geoip_google", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geoip/google.srs", "download_detour": "DIRECT" },
      { "tag": "geoip_netflix", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geoip/netflix.srs", "download_detour": "DIRECT" },
      { "tag": "geoip_telegram", "type": "remote", "format": "binary", "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geoip/telegram.srs", "download_detour": "DIRECT" }
    ],
    "final": "proxy",
    "auto_detect_interface": true,
    "override_android_vpn": true,
    "default_domain_resolver": "dns_local"
  },
  "experimental": {
    "cache_file": { "enabled": true, "path": "cache.db", "cache_id": "singbox", "store_fakeip": true, "store_rdrc": true },
    "clash_api": { "external_controller": "127.0.0.1:9090", "external_ui": "ui", "external_ui_download_url": "https://ghfast.top/https://github.com/MetaCubeX/metacubexd/archive/refs/heads/gh-pages.zip", "external_ui_download_detour": "DIRECT", "default_mode": "rule" }
  }
};

// =========================================
// 2. 核心解析逻辑
// =========================================

function safeBase64Decode(str) {
    try {
        return decodeURIComponent(escape(window.atob(str.replace(/-/g, '+').replace(/_/g, '/').replace(/\s/g, ''))));
    } catch { return str; }
}

function updateStatus(msg, type='normal') {
    document.getElementById('statusMsg').textContent = msg;
    const dot = document.getElementById('statusDot');
    dot.className = 'dot ' + (type === 'success' ? 'active' : '');
}

/**
 * Quantumult X (SubStore) 格式解析器
 * 格式: vmess=example.com:443, method=none, password=..., tag=NodeName
 */
function parseQX(line) {
    const parts = line.split(',');
    if (parts.length < 2) return null;

    const [head, ...params] = parts;
    const [type, address] = head.split('=');
    const [server, port] = address.trim().split(':');

    const args = {};
    params.forEach(p => {
        const [k, v] = p.split('=');
        if(k && v) args[k.trim()] = v.trim();
    });

    const node = {
        tag: args.tag || 'QX Node',
        server: server,
        server_port: parseInt(port)
    };

    if (type === 'vmess') {
        node.type = 'vmess';
        node.uuid = args.password || args.id; // QX vmess password is uuid
        node.alter_id = 0;
        node.security = args.method || 'auto'; // chacha20-poly1305 etc
        node.packet_encoding = 'xudp';

        // QX TLS / Obfs mapping
        if (args['obfs'] === 'wss' || args['obfs'] === 'websocket' || args['over-tls'] === 'true') {
            node.tls = {
                enabled: true,
                server_name: args['obfs-host'] || args['tls-host'] || server,
                insecure: args['tls-verification'] === 'false',
                utls: { enabled: true, fingerprint: 'chrome' }
            };
        }
        
        if (args['obfs'] === 'wss' || args['obfs'] === 'websocket') {
             node.transport = {
                 type: 'ws',
                 path: args['obfs-uri'] || '/',
                 headers: args['obfs-host'] ? { Host: args['obfs-host'] } : {}
             };
        }
    } else if (type === 'trojan') {
        node.type = 'trojan';
        node.password = args.password;
        node.tls = {
            enabled: true,
            server_name: args['tls-host'] || args['obfs-host'] || server,
            insecure: args['tls-verification'] === 'false',
            utls: { enabled: true, fingerprint: 'chrome' }
        };
        if (args['obfs'] === 'wss') {
            node.transport = { type: 'ws', path: args['obfs-uri'] || '/' };
        }
    } else if (type === 'shadowsocks') {
        node.type = 'shadowsocks';
        node.method = args.method;
        node.password = args.password;
    } else if (type === 'http') {
        node.type = 'http';
        node.username = args.username;
        node.password = args.password;
    } else {
        return null; 
    }
    return node;
}

/**
 * 通用对象转换器
 */
function transformToSingbox(item, type) {
    if (type === 'qx') return parseQX(item);
    
    // Clash Object
    if (type === 'clash') {
        const node = { tag: item.name || 'Unnamed', server: item.server, server_port: parseInt(item.port) };
        if (item.type === 'vless') {
            node.type = 'vless'; node.uuid = item.uuid; node.flow = item.flow || ''; node.packet_encoding = 'xudp';
            if (item.tls) {
                node.tls = { enabled: true, server_name: item.servername, insecure: item['skip-cert-verify'], utls: { enabled: true, fingerprint: item['client-fingerprint'] || 'chrome' } };
                if (item['reality-opts']) node.tls.reality = { enabled: true, public_key: item['reality-opts']['public-key'], short_id: item['reality-opts']['short-id'] };
            }
            if (item.network === 'ws') node.transport = { type: 'ws', path: item['ws-opts']?.path, headers: item['ws-opts']?.headers };
            if (item.network === 'grpc') node.transport = { type: 'grpc', service_name: item['grpc-opts']?.['grpc-service-name'] };
        } else if (item.type === 'vmess') {
            node.type = 'vmess'; node.uuid = item.uuid; node.alter_id = item.alterId || 0; node.security = item.cipher || 'auto'; node.packet_encoding = 'xudp';
            if (item.tls) node.tls = { enabled: true, server_name: item.servername, insecure: item['skip-cert-verify'], utls: { enabled: true, fingerprint: 'chrome'} };
            if (item.network === 'ws') node.transport = { type: 'ws', path: item['ws-opts']?.path, headers: item['ws-opts']?.headers };
            if (item.network === 'grpc') node.transport = { type: 'grpc', service_name: item['grpc-opts']?.['grpc-service-name'] };
        } else if (item.type === 'ss') {
            node.type = 'shadowsocks'; node.method = item.cipher; node.password = item.password;
        } else if (item.type === 'trojan') {
            node.type = 'trojan'; node.password = item.password; 
            node.tls = { enabled: true, server_name: item.sni || item.server, insecure: item['skip-cert-verify'], utls: { enabled: true, fingerprint: 'chrome'} };
            if (item.network === 'ws') node.transport = { type: 'ws', path: item['ws-opts']?.path };
        } else if (item.type === 'hysteria2') {
             node.type = 'hysteria2'; node.password = item.password; 
             node.tls = { enabled: true, server_name: item.sni || item.server, insecure: item['skip-cert-verify'], utls: { enabled: true, fingerprint: 'chrome'} };
             if(item.obfs) node.obfs = { type: 'salamander', password: item['obfs-password'] };
        } else return null;
        return node;
    }
    
    // Singbox Object
    if (type === 'singbox') { return (item.type && item.type !== 'selector' && item.type !== 'urltest') ? item : null; }
    
    // Xray Object
    if (type === 'xray') {
        const vnext = item.settings?.vnext?.[0]; if (!vnext) return null;
        const node = { tag: item.tag || 'Xray', server: vnext.address, server_port: parseInt(vnext.port) };
        const user = vnext.users[0]; const stream = item.streamSettings || {};
        if (item.protocol === 'vless') { node.type = 'vless'; node.uuid = user.id; node.flow = user.flow || ''; node.packet_encoding = 'xudp'; }
        else if (item.protocol === 'vmess') { node.type = 'vmess'; node.uuid = user.id; node.alter_id = user.alterId||0; node.security = user.security||'auto'; }
        else return null;
        
        if (stream.security === 'tls' || stream.security === 'reality') {
            const tls = stream.tlsSettings || stream.realitySettings || {};
            node.tls = { enabled: true, server_name: tls.serverName||tls.sni, insecure: tls.allowInsecure, utls: {enabled: true, fingerprint: tls.fingerprint||'chrome'} };
            if (stream.security === 'reality') node.tls.reality = { enabled: true, public_key: tls.publicKey, short_id: tls.shortId };
        }
        if (stream.network === 'ws') node.transport = { type: 'ws', path: stream.wsSettings?.path, headers: stream.wsSettings?.headers };
        if (stream.network === 'grpc') node.transport = { type: 'grpc', service_name: stream.grpcSettings?.serviceName };
        return node;
    }

    // Surge Line
    if (type === 'surge') {
        const [tagInfo, ...rest] = item.split('=');
        const details = rest.join('=').split(',').map(s=>s.trim());
        const node = { tag: tagInfo.trim(), server: details[1], server_port: parseInt(details[2]) };
        const args = {}; details.slice(3).forEach(p=>{const[k,v]=p.split('='); if(k) args[k.trim()]=v?v.trim():'true';});
        
        if (details[0] === 'vless') {
             node.type = 'vless'; node.uuid = args.username; node.flow = args.flow||''; node.packet_encoding = 'xudp';
             if (args.tls === 'true') node.tls = { enabled: true, server_name: args.sni, insecure: args['skip-cert-verify']==='true' };
             if (args.ws === 'true') node.transport = { type: 'ws', path: args['ws-path'], headers: args['ws-headers']?{Host:args['ws-headers'].split(':')[1]}:{} };
        } else if (details[0] === 'ss') {
             node.type = 'shadowsocks'; node.method = args.encrypt-method; node.password = args.password;
        } else return null;
        return node;
    }
    return null;
}

// =========================================
// 3. 混合解析入口
// =========================================
function parseMixedInput(text) {
    const rawLines = text.split(/\r?\n/);
    const nodes = [];
    let buffer = [];

    const processBuffer = () => {
        if (!buffer.length) return;
        const block = buffer.join('\n').trim();
        
        // JSON Detect
        if (block.startsWith('{')) {
            try {
                const j = JSON.parse(block);
                if (j.type && j.server) nodes.push(transformToSingbox(j, 'singbox'));
                else if (j.protocol && j.settings) nodes.push(transformToSingbox(j, 'xray'));
                else if (j.outbounds) j.outbounds.forEach(o => nodes.push(transformToSingbox(o, 'singbox')));
            } catch {}
        }
        // Clash YAML Detect
        else if (block.includes(':') && !block.includes('=')) {
            try {
                if (block.trim().startsWith('-')) { jsyaml.load(block).forEach(i => nodes.push(transformToSingbox(i, 'clash'))); }
                else { const y = jsyaml.load(block); if(y.proxies) y.proxies.forEach(i=>nodes.push(transformToSingbox(i,'clash'))); else nodes.push(transformToSingbox(y,'clash')); }
            } catch {}
        }
        buffer = [];
    }

    for (let line of rawLines) {
        line = line.trim();
        if (!line) { processBuffer(); continue; }

        // QX / SubStore Line Detect (vmess=..., trojan=...)
        if ((line.startsWith('vmess=') || line.startsWith('trojan=') || line.startsWith('http=') || line.startsWith('shadowsocks=')) && line.includes(',')) {
            processBuffer();
            const node = transformToSingbox(line, 'qx');
            if(node) nodes.push(node);
            continue;
        }

        // Surge Line Detect
        if (line.includes('=') && line.includes(',') && !line.startsWith('{') && !line.includes('proxies:')) {
            processBuffer();
            const node = transformToSingbox(line, 'surge');
            if(node) nodes.push(node);
            continue;
        }
        
        // URI Link
        if (line.includes('://')) {
             processBuffer();
             // 简单处理链接，实际可复用之前的 parseLink 逻辑，这里为简化省略，
             // 但 Base64 解码通常已经将链接转为上述格式之一或纯文本
             // 若 SubStore 导出的是纯链接列表，通常会自动被 Base64 解码逻辑覆盖
             continue; 
        }

        buffer.push(line);
        if (line === '}' || line === '],') processBuffer();
    }
    processBuffer();
    return nodes.filter(n => n);
}

// =========================================
// 4. 主程序
// =========================================
function convert() {
    let input = document.getElementById('input').value;
    if (!input.trim()) return;

    // 1. 尝试 Base64 解码 (SubStore 订阅通常是 Base64)
    if (!input.includes('\n') && !input.startsWith('{') && !input.startsWith('proxies:')) {
        const decoded = safeBase64Decode(input);
        if (decoded !== input) input = decoded;
    }

    // 2. 解析
    const nodes = parseMixedInput(input);
    if (!nodes.length) { updateStatus('未识别到有效节点', 'error'); return; }

    // 3. 去重
    const tagCount = {};
    const tags = [];
    const uniqueNodes = [];
    nodes.forEach(n => {
        if(tagCount[n.tag]) { tagCount[n.tag]++; n.tag = `${n.tag} ${tagCount[n.tag]}`; } else tagCount[n.tag]=1;
        tags.push(n.tag);
        uniqueNodes.push(n);
    });

    // 4. 组装
    const config = JSON.parse(JSON.stringify(TEMPLATE));
    const selectors = [
        { "type": "direct", "tag": "DIRECT" },
        { "type": "selector", "tag": "proxy", "outbounds": ["auto", ...tags, "DIRECT"], "default": "auto" },
        { "type": "urltest", "tag": "auto", "outbounds": tags, "url": "https://www.gstatic.com/generate_204", "interval": "10m", "tolerance": 50 }
    ];
    
    ["google", "apple", "telegram", "bilibili", "netflix", "bahamut", "youtube", "openai", "GLOBAL", "cn"].forEach(k => {
        selectors.push({ "type": "selector", "tag": k, "outbounds": ["proxy", "auto", "DIRECT", ...tags], "default": "proxy" });
    });
    selectors.push({ "type": "selector", "tag": "final", "outbounds": ["proxy", "DIRECT"], "default": "proxy" });

    config.outbounds = [...selectors, ...uniqueNodes];
    document.getElementById('output').value = JSON.stringify(config, null, 2);
    document.getElementById('nodeCount').textContent = `节点: ${uniqueNodes.length}`;
    updateStatus(`成功生成 ${uniqueNodes.length} 个节点`, 'success');
}

function clearInput() { document.getElementById('input').value = ''; document.getElementById('output').value = ''; updateStatus('已清空'); }
function copyResult() { document.getElementById('output').select(); document.execCommand('copy'); updateStatus('已复制', 'success'); }
document.getElementById('input').addEventListener('input', () => { if(document.getElementById('autoMode').checked) setTimeout(convert, 500); });
</script>
</body>
</html>
