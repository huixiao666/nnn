<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sing-box Converter (Template: CF-CCS 1.11.4)</title>
    <!-- 引入 YAML 解析库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --border: #334155;
            --success: #10b981;
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        header {
            padding: 0 24px;
            height: 64px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(8px);
        }

        h1 { margin: 0; font-size: 1.25rem; font-weight: 700; display: flex; align-items: center; gap: 10px; }
        .tag { font-size: 0.75rem; background: var(--border); padding: 2px 8px; border-radius: 4px; color: var(--text-secondary); }

        .container {
            flex: 1;
            display: flex;
            padding: 20px;
            gap: 20px;
            overflow: hidden;
        }

        .panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .panel-header {
            padding: 12px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .editor-wrapper {
            flex: 1;
            position: relative;
        }

        textarea {
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
            color: var(--text-primary);
            padding: 20px;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: none;
            outline: none;
            box-sizing: border-box;
        }

        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 6px 16px;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover { background: var(--accent-hover); }
        .btn-ghost { background: transparent; color: var(--text-secondary); border: 1px solid var(--border); }
        .btn-ghost:hover { border-color: var(--text-secondary); color: var(--text-primary); }

        footer {
            height: 40px;
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            background: var(--card-bg);
        }

        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text-secondary); margin-right: 8px; display: inline-block; }
        .status-dot.active { background: var(--success); box-shadow: 0 0 8px rgba(16, 185, 129, 0.4); }

        @media (max-width: 768px) {
            .container { flex-direction: column; }
        }
    </style>
</head>
<body>

<header>
    <h1>Sing-box Converter <span class="tag">CF-CCS Template</span></h1>
    <div style="display: flex; gap: 12px; align-items: center;">
        <label style="font-size: 0.875rem; color: var(--text-secondary); display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="checkbox" id="autoMode" checked> 自动转换
        </label>
        <button class="btn" onclick="convert()">转换</button>
    </div>
</header>

<div class="container">
    <div class="panel">
        <div class="panel-header">
            <span>输入 (Mixed: Clash/Xray/Singbox/Surge/Links)</span>
            <button class="btn-ghost" style="padding: 4px 10px; font-size: 12px;" onclick="clearInput()">清空</button>
        </div>
        <div class="editor-wrapper">
            <textarea id="input" placeholder="请在此粘贴配置。支持混合粘贴：
1. Clash Meta YAML (Proxy Block)
2. Sing-box JSON (Outbound Object)
3. Xray JSON (Outbound Object)
4. Surge Proxy Line (Node = type, server...)
5. vmess://, vless:// 等链接"></textarea>
        </div>
    </div>
    <div class="panel">
        <div class="panel-header">
            <span>输出 (Sing-box 1.11.4 Config)</span>
            <button class="btn-ghost" style="padding: 4px 10px; font-size: 12px;" onclick="copyResult()">复制</button>
        </div>
        <div class="editor-wrapper">
            <textarea id="output" readonly placeholder="等待生成..."></textarea>
        </div>
    </div>
</div>

<footer>
    <div style="display: flex; align-items: center;">
        <span class="status-dot" id="statusDot"></span>
        <span id="statusMsg">就绪</span>
    </div>
    <span id="nodeCount">节点数: 0</span>
</footer>

<script>
/**
 * 核心模板 (基于 cf-ccs.txt - Sing-box 1.11.4)
 * 注意：Outbounds 将在转换时动态重构
 */
const BASE_TEMPLATE = {
  "dns": {
    "servers": [
      { "tag": "local", "address": "https://223.5.5.5/dns-query", "detour": "DIRECT" },
      { "tag": "google", "address": "https://8.8.8.8/dns-query", "detour": "proxy" },
      { "tag": "cloudflare", "address": "https://1.1.1.1/dns-query", "detour": "proxy" },
      { "tag": "ali", "address": "https://223.5.5.5/dns-query", "detour": "DIRECT" },
      { "tag": "block", "address": "rcode://success" }
    ],
    "rules": [
      { "clash_mode": "Direct", "server": "ali" },
      { "clash_mode": "Global", "server": "google" },
      { "query_type": "HTTPS", "server": "local" },
      { "domain_suffix": [".cn"], "server": "ali" },
      { "domain_keyword": ["baidu", "qq", "taobao", "alipay", "weibo", "jd"], "server": "ali" },
      { "domain_suffix": [".google.com", ".youtube.com", ".netflix.com"], "server": "google" },
      { "domain_keyword": ["adservice", "analytics", "ad-", "doubleclick"], "server": "block" }
    ],
    "final": "google",
    "strategy": "ipv4_only",
    "independent_cache": true
  },
  "inbounds": [
    {
      "type": "tun",
      "tag": "tun-in",
      "address": ["172.19.0.1/30"],
      "mtu": 1500,
      "stack": "mixed",
      "auto_route": true,
      "strict_route": true,
      "sniff": true,
      "sniff_override_destination": false,
      "platform": { "http_proxy": { "enabled": true, "server": "127.0.0.1", "server_port": 7890 } }
    },
    {
      "type": "mixed",
      "tag": "mixed-in",
      "listen": "127.0.0.1",
      "listen_port": 7890,
      "sniff": true,
      "sniff_override_destination": false,
      "set_system_proxy": false
    }
  ],
  "outbounds": [], // 将由 convert 函数动态生成
  "route": {
    "rules": [
      { "protocol": "dns", "outbound": "DNS-OUT" },
      { "domain_suffix": [".t.me", ".telegram.org", ".telegram.me"], "outbound": "telegram" },
      { "ip_cidr": ["91.108.4.0/22", "91.108.8.0/22", "91.108.12.0/22", "91.108.16.0/22", "91.108.56.0/22", "149.154.160.0/20"], "outbound": "telegram" },
      { "clash_mode": "Direct", "outbound": "DIRECT" },
      { "clash_mode": "Global", "outbound": "GLOBAL" },
      { "network": "udp", "port": 443, "outbound": "BLOCK" },
      { "ip_is_private": true, "outbound": "DIRECT" },
      { "domain_suffix": [".cn"], "outbound": "DIRECT" },
      { "domain_keyword": ["baidu", "qq", "taobao", "alipay", "weibo", "jd", "tmall"], "outbound": "DIRECT" },
      { "domain_suffix": [".bilibili.com", ".hdslb.com"], "outbound": "bilibili" },
      { "domain_suffix": [".apple.com", ".icloud.com", ".appstore.com"], "outbound": "apple" },
      { "domain_keyword": ["adservice", "analytics", "ad-", "doubleclick", "googleads"], "outbound": "BLOCK" },
      { "domain_suffix": [".google.com", ".googleapis.com", ".gstatic.com"], "outbound": "google" },
      { "domain_suffix": [".netflix.com", ".nflxvideo.net", ".nflximg.net"], "outbound": "netflix" },
      { "domain_suffix": [".youtube.com", ".googlevideo.com", ".ytimg.com"], "outbound": "youtube" },
      { "domain_suffix": [".openai.com", ".ai.com"], "outbound": "openai" },
      { "ip_cidr": ["1.0.1.0/24", "1.0.2.0/23", "1.1.1.0/24"], "outbound": "proxy" }
    ],
    "final": "proxy",
    "auto_detect_interface": true,
    "override_android_vpn": true
  },
  "experimental": {
    "clash_api": {
      "external_controller": "127.0.0.1:9090",
      "external_ui": "ui",
      "external_ui_download_url": "https://ghfast.top/https://github.com/MetaCubeX/metacubexd/archive/refs/heads/gh-pages.zip",
      "external_ui_download_detour": "DIRECT",
      "default_mode": "rule"
    },
    "cache_file": { "enabled": true, "path": "cache.db", "cache_id": "singbox" }
  }
};

/**
 * 工具函数
 */
const safeBase64Decode = (str) => {
    try {
        return decodeURIComponent(escape(window.atob(str.replace(/-/g, '+').replace(/_/g, '/'))));
    } catch {
        return str; // Return original if not base64
    }
};

const updateStatus = (msg, type = 'normal') => {
    const dot = document.getElementById('statusDot');
    const txt = document.getElementById('statusMsg');
    txt.textContent = msg;
    dot.className = 'status-dot ' + (type === 'success' ? 'active' : type === 'error' ? 'error' : '');
    if(type === 'error') dot.style.background = '#ef4444';
};

/**
 * 核心转换逻辑：将任意对象转换为 Sing-box 节点
 */
const transformToSingbox = (item, type) => {
    // 1. Sing-box Native Object
    if (type === 'singbox') {
        if (!item.type || item.type === 'selector' || item.type === 'urltest') return null;
        return item;
    }

    // 2. Clash Object (Mihomo)
    if (type === 'clash') {
        const node = {
            tag: item.name || 'Unnamed',
            server: item.server,
            server_port: parseInt(item.port)
        };

        if (item.type === 'vless') {
            node.type = 'vless';
            node.uuid = item.uuid;
            node.flow = item.flow || '';
            node.packet_encoding = item['packet-encoding'] || 'xudp';
            
            if (item.tls) {
                node.tls = {
                    enabled: true,
                    server_name: item.servername,
                    insecure: item['skip-cert-verify'] || false,
                    utls: { enabled: true, fingerprint: item['client-fingerprint'] || 'chrome' }
                };
                if (item['reality-opts']) {
                    node.tls.reality = {
                        enabled: true,
                        public_key: item['reality-opts']['public-key'],
                        short_id: item['reality-opts']['short-id']
                    };
                }
            }

            if (item.network === 'ws') {
                node.transport = {
                    type: 'ws',
                    path: item['ws-opts']?.path,
                    headers: item['ws-opts']?.headers || item['ws-headers']
                };
                if (item['ws-opts']?.['max-early-data']) {
                   node.transport.max_early_data = item['ws-opts']['max-early-data'];
                   node.transport.early_data_header_name = "Sec-WebSocket-Protocol";
                }
            } else if (item.network === 'grpc') {
                node.transport = {
                    type: 'grpc',
                    service_name: item['grpc-opts']?.['grpc-service-name']
                };
            }
        }
        else if (item.type === 'vmess') {
            node.type = 'vmess';
            node.uuid = item.uuid;
            node.alter_id = item.alterId || 0;
            node.security = item.cipher || 'auto';
            node.packet_encoding = 'xudp';
            if(item.tls) {
                node.tls = { enabled: true, server_name: item.servername, insecure: item['skip-cert-verify'] };
                if(item['client-fingerprint']) node.tls.utls = { enabled: true, fingerprint: item['client-fingerprint'] };
            }
            if(item.network === 'ws') node.transport = { type: 'ws', path: item['ws-opts']?.path, headers: item['ws-opts']?.headers };
            if(item.network === 'grpc') node.transport = { type: 'grpc', service_name: item['grpc-opts']?.['grpc-service-name'] };
        }
        else if (item.type === 'ss') {
            node.type = 'shadowsocks';
            node.method = item.cipher;
            node.password = item.password;
        }
        else if (item.type === 'trojan') {
            node.type = 'trojan';
            node.password = item.password;
            node.tls = { enabled: true, server_name: item.sni || item.server, insecure: item['skip-cert-verify'] };
        }
        else if (item.type === 'hysteria2') {
            node.type = 'hysteria2';
            node.password = item.password;
            node.tls = { enabled: true, server_name: item.sni || item.server, insecure: item['skip-cert-verify'] };
            if(item.obfs) node.obfs = { type: 'salamander', password: item['obfs-password'] };
        }
        else { return null; }
        return node;
    }

    // 3. Xray Object (Outbound)
    if (type === 'xray') {
        if (!item.settings?.vnext?.[0]) return null;
        const vnext = item.settings.vnext[0];
        const user = vnext.users[0];
        const stream = item.streamSettings || {};
        
        const node = {
            tag: item.tag || 'Xray Node',
            server: vnext.address,
            server_port: parseInt(vnext.port)
        };

        if (item.protocol === 'vless') {
            node.type = 'vless';
            node.uuid = user.id;
            node.flow = user.flow || '';
            node.packet_encoding = 'xudp';
        } else if (item.protocol === 'vmess') {
            node.type = 'vmess';
            node.uuid = user.id;
            node.alter_id = user.alterId || 0;
            node.security = user.security || 'auto';
        } else { return null; }

        // TLS
        const security = stream.security;
        if (security === 'tls' || security === 'reality') {
            const tlsSets = stream.tlsSettings || stream.realitySettings || {};
            node.tls = {
                enabled: true,
                server_name: tlsSets.serverName || tlsSets.sni,
                insecure: tlsSets.allowInsecure || false,
                utls: { enabled: true, fingerprint: tlsSets.fingerprint || 'chrome' }
            };
            if (security === 'reality') {
                node.tls.reality = {
                    enabled: true,
                    public_key: tlsSets.publicKey,
                    short_id: tlsSets.shortId
                };
            }
        }

        // Transport
        if (stream.network === 'ws') {
            node.transport = {
                type: 'ws',
                path: stream.wsSettings?.path,
                headers: stream.wsSettings?.headers
            };
        } else if (stream.network === 'grpc') {
            node.transport = {
                type: 'grpc',
                service_name: stream.grpcSettings?.serviceName
            };
        }
        return node;
    }

    // 4. Surge Line (Tag = type, server, port, args)
    if (type === 'surge') {
        const [tagInfo, ...rest] = item.split('=');
        const tag = tagInfo.trim();
        const details = rest.join('=').trim().split(',').map(s => s.trim());
        const protocol = details[0];
        const server = details[1];
        const port = details[2];
        
        const args = {};
        details.slice(3).forEach(part => {
            const [k, v] = part.split('=');
            if(k && v) args[k.trim()] = v.trim();
            else if (k) args[k.trim()] = "true";
        });

        const node = { tag, server, server_port: parseInt(port) };
        
        if (protocol === 'vless') {
            node.type = 'vless';
            node.uuid = args.username;
            node.flow = args.flow || '';
            node.packet_encoding = 'xudp';
            
            if (args.tls === 'true') {
                node.tls = {
                    enabled: true,
                    server_name: args.sni,
                    insecure: args['skip-cert-verify'] === 'true'
                };
            }
            if (args.ws === 'true') {
                node.transport = {
                    type: 'ws',
                    path: args['ws-path'],
                    headers: args['ws-headers'] ? { Host: args['ws-headers'].split(':')[1] } : {}
                };
            }
        } 
        else { return null; }
        
        return node;
    }

    return null;
};

/**
 * 智能解析入口
 */
function parseMixedInput(text) {
    const rawLines = text.split(/\r?\n/);
    const nodes = [];

    let buffer = [];
    
    const processBuffer = () => {
        if (buffer.length === 0) return;
        const block = buffer.join('\n').trim();
        
        if (block.startsWith('{')) {
            try {
                const json = JSON.parse(block);
                if (json.type && json.server) nodes.push(transformToSingbox(json, 'singbox'));
                else if (json.protocol && json.settings) nodes.push(transformToSingbox(json, 'xray'));
                else if (json.outbounds) json.outbounds.forEach(o => nodes.push(transformToSingbox(o, 'singbox')));
            } catch (e) {}
        }
        else if (block.includes(':') && !block.includes('=')) {
            try {
                if (block.trim().startsWith('-')) {
                    const yaml = jsyaml.load(block);
                    if (Array.isArray(yaml)) yaml.forEach(i => nodes.push(transformToSingbox(i, 'clash')));
                } 
                else {
                    const yaml = jsyaml.load(block);
                    if (yaml.name && yaml.server && yaml.type) nodes.push(transformToSingbox(yaml, 'clash'));
                    else if (yaml.proxies) yaml.proxies.forEach(i => nodes.push(transformToSingbox(i, 'clash')));
                }
            } catch (e) {}
        }
        
        buffer = [];
    };

    for (let line of rawLines) {
        line = line.trim();
        if (!line) {
            processBuffer();
            continue;
        }

        if (line.includes('=') && line.includes(',') && !line.startsWith('{') && !line.includes(': ')) {
            processBuffer();
            const node = transformToSingbox(line, 'surge');
            if (node) nodes.push(node);
            continue;
        }

        // TODO: 链接解析 (vmess://, etc) 可在此处添加
        
        buffer.push(line);
        if (line === '}' || line === '],') processBuffer();
    }
    processBuffer();

    return nodes.filter(n => n !== null);
}

/**
 * 主程序
 */
function convert() {
    const input = document.getElementById('input').value;
    if (!input.trim()) return;

    let textToParse = input;
    if (!input.includes('\n') && !input.includes(' ') && input.length > 50) {
        const decoded = safeBase64Decode(input);
        if (decoded !== input) textToParse = decoded;
    }

    const nodes = parseMixedInput(textToParse);

    if (nodes.length === 0) {
        updateStatus('未识别到有效节点', 'error');
        return;
    }

    // 复制模板
    const config = JSON.parse(JSON.stringify(BASE_TEMPLATE));
    const tags = nodes.map(n => n.tag);
    
    // -------------------------------------------------------------
    // 构建 Outbounds - 复刻 cf-ccs.txt 的路由结构
    // -------------------------------------------------------------

    // 1. 基础节点
    const baseOutbounds = [
        { "type": "direct", "tag": "DIRECT" },
        { "type": "block", "tag": "BLOCK" },
        { "type": "dns", "tag": "DNS-OUT" }
    ];

    // 2. 自动测速组 (包含所有用户节点)
    const urlTestGroups = [
        { 
            "type": "urltest", "tag": "auto", "outbounds": tags, 
            "url": "https://www.gstatic.com/generate_204", "interval": "3m", "tolerance": 50, "idle_timeout": "30m", "interrupt_exist_connections": false 
        },
        { 
            "type": "urltest", "tag": "⚡️ CF-Auto-Best", "outbounds": tags, 
            "url": "https://www.gstatic.com/generate_204", "interval": "1m", "tolerance": 50, "interrupt_exist_connections": false 
        },
        { 
            "type": "urltest", "tag": "us-auto", "outbounds": tags, 
            "url": "https://www.gstatic.com/generate_204", "interval": "1m", "tolerance": 50, "interrupt_exist_connections": false 
        },
        { 
            "type": "urltest", "tag": "all-auto", "outbounds": tags, 
            "url": "https://www.gstatic.com/generate_204", "interval": "1m", "tolerance": 50, "interrupt_exist_connections": false 
        }
    ];

    // 3. 手动选择组 (包含所有用户节点)
    const manualSelectors = [
        { "type": "selector", "tag": "us", "outbounds": tags, "interrupt_exist_connections": false },
        { "type": "selector", "tag": "all", "outbounds": ["pkpk reality-vision", "pkpk reality-grpc", ...tags], "interrupt_exist_connections": false } // 示例中all包含所有
    ];
    // 修正: 转换器无法区分 "us" 节点，所以 "us" 和 "all" 都包含所有 tags

    // 4. 核心 Proxy 组
    const proxySelector = {
        "type": "selector",
        "tag": "proxy",
        "outbounds": [
            "auto",
            "⚡️ CF-Auto-Best",
            "us",
            "all",
            "us-auto",
            "all-auto",
            ...tags,
            "DIRECT"
        ],
        "default": "auto",
        "interrupt_exist_connections": false
    };

    // 5. 应用/规则策略组 (google, telegram 等)
    // 它们的出站选项通常包含 proxy, 测速组, 直连 和 区域组
    const ruleGroupsList = ["google", "apple", "telegram", "bilibili", "netflix", "youtube", "openai", "GLOBAL", "final"];
    const commonRuleOutbounds = ["proxy", "⚡️ CF-Auto-Best", "DIRECT", "us", "us-auto", "all", "all-auto"];
    
    const ruleSelectors = ruleGroupsList.map(tag => ({
        "type": "selector",
        "tag": tag,
        "outbounds": tag === "GLOBAL" ? ["DIRECT", ...commonRuleOutbounds] : commonRuleOutbounds,
        "default": tag === "apple" || tag === "bilibili" ? "DIRECT" : "proxy",
        "interrupt_exist_connections": false
    }));

    // 组装所有 Outbounds
    config.outbounds = [
        ...baseOutbounds,
        proxySelector,
        ...urlTestGroups,
        ...manualSelectors,
        ...ruleSelectors,
        ...nodes // 用户的节点
    ];

    // 4. 输出
    document.getElementById('output').value = JSON.stringify(config, null, 2);
    document.getElementById('nodeCount').textContent = `节点数: ${nodes.length}`;
    updateStatus(`成功生成 ${nodes.length} 个节点`, 'success');
}

function clearInput() {
    document.getElementById('input').value = '';
    document.getElementById('output').value = '';
    document.getElementById('nodeCount').textContent = '节点数: 0';
    updateStatus('已清空');
}

function copyResult() {
    document.getElementById('output').select();
    document.execCommand('copy');
    updateStatus('已复制!', 'success');
}

// 自动转换监听
document.getElementById('input').addEventListener('input', () => {
    if (document.getElementById('autoMode').checked) {
        clearTimeout(window.debounce);
        window.debounce = setTimeout(convert, 500);
    }
});

</script>
</body>
</html>
