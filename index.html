<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sing-box</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --bg-gradient: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            --card-bg: rgba(255, 255, 255, 0.05);
            --card-border: rgba(255, 255, 255, 0.1);
            --primary: #6d5dfc;
            --primary-hover: #5b4ef0;
            --text-primary: #f0f0f0;
            --text-secondary: #b0b0c0;
            --success: #4cd964;
            --warning: #ffcc00;
            --error: #ff3b30;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            --glow: 0 0 20px rgba(109, 93, 252, 0.3);
            --header-height: 80px;
            --footer-height: 60px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: var(--bg-gradient);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* PC端默认禁止body滚动，由内部容器滚动 */
        }

        /* ====================
           自定义滚动条 (修复auto问题)
           ==================== */
        ::-webkit-scrollbar {
            width: 8px;    /* 修复：使用固定像素而不是 auto */
            height: 8px;   /* 修复：使用固定像素而不是 auto */
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(109, 93, 252, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(109, 93, 252, 0.6);
        }

        /* 头部区域 */
        .header {
            height: var(--header-height);
            padding: 0 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            background: rgba(26, 26, 46, 0.9);
            z-index: 100;
            flex-shrink: 0;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo-icon {
            background: var(--primary);
            width: 40px;
            height: 40px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            box-shadow: var(--glow);
        }

        .logo-text {
            font-size: 1.5rem;
            font-weight: 700;
            color: #fff;
        }

        .version-badge {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.2rem 0.6rem;
            border-radius: 6px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls {
            display: flex;
            gap: 1rem;
        }

        .btn {
            padding: 0.6rem 1.2rem;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            white-space: nowrap;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 15px rgba(109, 93, 252, 0.3);
        }

        .btn-primary:active { transform: scale(0.98); }
        .btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .btn-secondary:hover { background: rgba(255, 255, 255, 0.1); }
        .btn-secondary:active { transform: scale(0.98); }

        /* 主内容区域 - PC端布局 */
        .main {
            flex: 1;
            display: flex;
            padding: 1.5rem 2rem;
            gap: 1.5rem;
            overflow: hidden; /* 内部卡片滚动 */
            max-width: 1920px;
            margin: 0 auto;
            width: 100%;
        }

        .card {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: var(--shadow);
            height: 100%; /* PC端占满高度 */
        }

        .card-header {
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            background: rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }

        .card-title {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            font-weight: 600;
            font-size: 1rem;
        }

        .card-icon {
            color: var(--primary);
            font-size: 1.1rem;
        }

        .editor-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .editor {
            flex: 1;
            width: 100%;
            background: transparent;
            border: none;
            padding: 1.5rem;
            color: #e0e0e0;
            font-family: 'JetBrains Mono', Consolas, monospace;
            font-size: 0.95rem;
            line-height: 1.6;
            resize: none;
            outline: none;
        }

        .editor::placeholder { color: rgba(255, 255, 255, 0.2); }

        .status-indicator {
            position: absolute;
            top: 1rem;
            right: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.6);
            font-size: 0.75rem;
            color: var(--text-secondary);
            pointer-events: none;
            backdrop-filter: blur(4px);
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--text-secondary);
        }
        .status-dot.active { background: var(--success); box-shadow: 0 0 8px var(--success); }
        .status-dot.error { background: var(--error); box-shadow: 0 0 8px var(--error); }

        /* 底部状态栏 */
        .footer {
            height: var(--footer-height);
            padding: 0 2rem;
            background: rgba(0, 0, 0, 0.2);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            flex-shrink: 0;
        }

        .stats { display: flex; gap: 2rem; }
        .stat-item { color: var(--text-secondary); display: flex; gap: 0.5rem; align-items: center; }
        .stat-value { color: #fff; font-weight: 600; font-family: monospace; }
        .hint { color: var(--text-secondary); opacity: 0.7; }

        /* ====================
           移动端专属样式 (独立界面逻辑)
           ==================== */
        @media (max-width: 1024px) {
            body {
                height: auto; /* 允许页面整体滚动 */
                min-height: 100vh;
                overflow-y: auto; /* 恢复body滚动 */
            }

            /* 移动端头部 */
            .header {
                height: auto;
                flex-direction: column;
                padding: 1.5rem 1rem;
                gap: 1.2rem;
                position: sticky; /* 头部吸顶 */
                top: 0;
                background: rgba(26, 26, 46, 0.95);
            }

            .logo {
                width: 100%;
                justify-content: center;
            }

            .version-badge { display: none; /* 移动端隐藏版本号节省空间 */ }

            .controls {
                width: 100%;
                display: grid;
                grid-template-columns: 1fr 1.5fr 1fr; /* 中间转换按钮大一点 */
                gap: 0.8rem;
            }

            .btn {
                justify-content: center;
                padding: 0.8rem 0;
                font-size: 0.85rem;
                flex-direction: column; /* 图标文字上下排列 */
                gap: 0.3rem;
            }
            
            .btn i { font-size: 1.1rem; }

            /* 移动端主区域 */
            .main {
                flex-direction: column;
                padding: 1rem;
                gap: 1.5rem;
                overflow: visible; /* 让卡片自然撑开 */
            }

            .card {
                height: auto; /* 高度自适应 */
                min-height: 400px; /* 保证最小高度 */
                border-radius: 12px;
            }

            .card-header {
                padding: 0.8rem 1rem;
                background: rgba(255, 255, 255, 0.03);
            }

            .card-title { font-size: 0.9rem; }
            .card-icon { display: none; /* 移动端隐藏卡片图标 */ }

            .editor {
                font-size: 14px; /* 移动端字体调整 */
                padding: 1rem;
                min-height: 350px; /* 移动端输入框最小高度 */
            }

            /* 移动端底部 */
            .footer {
                height: auto;
                padding: 1rem;
                flex-direction: column;
                gap: 0.8rem;
                text-align: center;
                margin-bottom: 1rem;
            }

            .stats {
                gap: 1rem;
                justify-content: center;
                flex-wrap: wrap;
            }
            
            .hint { display: none; /* 移动端隐藏提示信息 */ }
        }
    </style>
</head>
<body>

    <div class="header">
        <div class="logo">
            <div class="logo-icon">
                <i class="fas fa-exchange-alt"></i>
            </div>
            <div class="logo-text">Sing-box指定1.13.0-rc.1版本</div>
            <div class="version-badge">指定1.13.0-rc.1版本</div>
        </div>
        
        <div class="controls">
            <button class="btn btn-secondary" onclick="clearInput()">
                <i class="fas fa-trash-alt"></i> <span>清空</span>
            </button>
            <button class="btn btn-primary" onclick="convert()">
                <i class="fas fa-bolt"></i> <span>转换配置</span>
            </button>
            <button class="btn btn-secondary" onclick="copyResult()">
                <i class="fas fa-copy"></i> <span>复制</span>
            </button>
        </div>
    </div>

    <div class="main">
        <!-- 输入卡片 -->
        <div class="card">
            <div class="card-header">
                <div class="card-title">
                    <div class="card-icon"><i class="fas fa-code"></i></div>
                    <div>输入 (Clash/URI/JSON)</div>
                </div>
            </div>
            <div class="editor-container">
                <div class="status-indicator" id="inputStatus">
                    <div class="status-dot"></div>
                    <span>等待输入</span>
                </div>
                <textarea id="inputArea" class="editor" placeholder="在此粘贴您的配置...&#10;支持格式：&#10;• VLESS/VMess/Trojan/SS 链接&#10;• Clash 订阅内容&#10;• 混合节点列表"></textarea>
            </div>
        </div>

        <!-- 输出卡片 -->
        <div class="card">
            <div class="card-header">
                <div class="card-title">
                    <div class="card-icon"><i class="fas fa-cogs"></i></div>
                    <div>输出 (Sing-box JSON)</div>
                </div>
            </div>
            <div class="editor-container">
                <div class="status-indicator" id="outputStatus">
                    <div class="status-dot"></div>
                    <span>等待结果</span>
                </div>
                <textarea id="outputArea" class="editor" readonly placeholder="转换后的配置将显示在这里..."></textarea>
            </div>
        </div>
    </div>

    <div class="footer">
        <div class="stats">
            <div class="stat-item">
                <i class="fas fa-server"></i>
                <span>节点: <span id="nodeCount" class="stat-value">0</span></span>
            </div>
            <div class="stat-item">
                <i class="fas fa-code-branch"></i>
                <span>Core: <span class="stat-value">1.13.0-rc.1</span></span>
            </div>
            <div class="stat-item">
                <i class="fas fa-clock"></i>
                <span>状态: <span id="statusText" class="stat-value">就绪</span></span>
            </div>
        </div>
        <div class="hint">
            <i class="fas fa-lightbulb"></i> 提示: 转换完全在本地进行，不会上传您的配置
        </div>
    </div>

    <script>
        // ==========================================
        // 1. 核心模板 (基于 1.13.0.txt)
        // ==========================================
        const TEMPLATE = {
  "dns": {
    "servers": [
      {
        "tag": "local",
        "type": "https",
        "server": "223.5.5.5"
      },
      {
        "tag": "google",
        "type": "https",
        "server": "8.8.8.8",
        "detour": "proxy"
      },
      {
        "tag": "cloudflare",
        "type": "https",
        "server": "1.1.1.1",
        "detour": "proxy"
      },
      {
        "tag": "ali",
        "type": "https",
        "server": "223.5.5.5"
      },
      {
        "tag": "fakeip",
        "type": "fakeip",
        "inet4_range": "198.18.0.0/15",
        "inet6_range": "fc00::/18"
      }
    ],
    "rules": [
      {
        "clash_mode": "Direct",
        "action": "route",
        "server": "ali"
      },
      {
        "clash_mode": "Global",
        "action": "route",
        "server": "fakeip"
      },
      {
        "query_type": "HTTPS",
        "action": "reject"
      },
      {
        "rule_set": "cn_domain",
        "action": "route",
        "server": "ali"
      },
      {
        "rule_set": "geosite-cn",
        "server": "ali"
      },
      {
        "rule_set": [
          "geosite-google",
          "geosite-netflix",
          "geosite-youtube"
        ],
        "server": "google"
      },
      {
        "rule_set": "geosite_adguard",
        "action": "reject",
        "disable_cache": true
      },
      {
        "rule_set": "geosite-category-ads-all",
        "action": "reject",
        "disable_cache": true
      },
      {
        "rule_set": "geosite_ads",
        "action": "reject",
        "disable_cache": true
      },
      {
        "query_type": [
          "A",
          "AAAA"
        ],
        "action": "route",
        "server": "fakeip",
        "rewrite_ttl": 1
      }
    ],
    "final": "google",
    "strategy": "ipv4_only",
    "independent_cache": true
  },
  "ntp": {
    "enabled": true,
    "server": "time.apple.com",
    "server_port": 123,
    "interval": "30m",
    "detour": "direct"
  },
  "inbounds": [
    {
      "type": "tun",
      "tag": "tun-in",
      "address": [
        "172.19.0.1/28"
      ],
      "mtu": 1280,
      "stack": "mixed",
      "auto_route": true,
      "strict_route": true,
      "sniff": true,
      "sniff_override_destination": false,
      "platform": {
        "http_proxy": {
          "enabled": true,
          "server": "127.0.0.1",
          "server_port": 7890
        }
      }
    },
    {
      "type": "mixed",
      "tag": "mixed-in",
      "listen": "127.0.0.1",
      "listen_port": 7890,
      "sniff": true,
      "sniff_override_destination": false,
      "set_system_proxy": false
    }
  ],
  "outbounds": [
    {
      "type": "direct",
      "tag": "direct"
    },
    {
      "type": "selector",
      "tag": "proxy",
      "outbounds": [
        "auto",
        "direct"
      ],
      "default": "auto",
      "interrupt_exist_connections": false
    },
    {
      "type": "urltest",
      "tag": "auto",
      "outbounds": [],
      "url": "https://www.gstatic.com/generate_204",
      "interval": "3m",
      "tolerance": 50,
      "idle_timeout": "30m",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "google",
      "outbounds": [
        "proxy",
        "auto",
        "direct"
      ],
      "default": "proxy",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "apple",
      "outbounds": [
        "direct",
        "proxy"
      ],
      "default": "direct",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "telegram",
      "outbounds": [
        "proxy",
        "auto"
      ],
      "default": "proxy",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "bilibili",
      "outbounds": [
        "direct",
        "proxy"
      ],
      "default": "direct",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "netflix",
      "outbounds": [
        "proxy",
        "auto"
      ],
      "default": "proxy",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "bahamut",
      "outbounds": [
        "proxy",
        "auto"
      ],
      "default": "proxy",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "youtube",
      "outbounds": [
        "proxy",
        "auto"
      ],
      "default": "proxy",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "openai",
      "outbounds": [
        "proxy",
        "auto"
      ],
      "default": "proxy",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "GLOBAL",
      "outbounds": [
        "direct",
        "proxy",
        "auto"
      ],
      "default": "direct",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "cn",
      "outbounds": [
        "direct",
        "proxy"
      ],
      "default": "direct",
      "interrupt_exist_connections": false
    },
    {
      "type": "selector",
      "tag": "final",
      "outbounds": [
        "proxy",
        "direct"
      ],
      "default": "proxy",
      "interrupt_exist_connections": false
    }
  ],
  "route": {
    "rules": [
      {
        "protocol": "quic",
        "action": "reject"
      },
      {
        "type": "logical",
        "mode": "or",
        "rules": [
          {
            "port": 53
          },
          {
            "protocol": "dns"
          }
        ],
        "action": "hijack-dns"
      },
      {
        "rule_set": "geosite-telegram",
        "action": "route",
        "outbound": "telegram"
      },
      {
        "rule_set": [
          "telegram_ip",
          "telegram_domain"
        ],
        "action": "route",
        "outbound": "telegram"
      },
      {
        "action": "sniff",
        "sniffer": [
          "http",
          "tls",
          "quic",
          "dns"
        ],
        "timeout": "500ms"
      },
      {
        "protocol": "dns",
        "action": "hijack-dns"
      },
      {
        "clash_mode": "Direct",
        "action": "route",
        "outbound": "direct"
      },
      {
        "clash_mode": "Global",
        "action": "route",
        "outbound": "GLOBAL"
      },
      {
        "network": "udp",
        "port": 443,
        "action": "reject"
      },
      {
        "ip_is_private": true,
        "action": "route",
        "outbound": "direct"
      },
      {
        "rule_set": "geosite-cn",
        "action": "route",
        "outbound": "direct"
      },
      {
        "rule_set": "geosite-bilibili",
        "action": "route",
        "outbound": "bilibili"
      },
      {
        "rule_set": "geosite-apple",
        "action": "route",
        "outbound": "apple"
      },
      {
        "rule_set": "geosite_adguard",
        "action": "reject"
      },
      {
        "rule_set": "geosite-category-ads-all",
        "action": "reject"
      },
      {
        "rule_set": "geosite_ads",
        "action": "reject"
      },
      {
        "rule_set": "geosite-google",
        "action": "route",
        "outbound": "google"
      },
      {
        "rule_set": "geosite-netflix",
        "action": "route",
        "outbound": "netflix"
      },
      {
        "rule_set": "geosite-youtube",
        "action": "route",
        "outbound": "youtube"
      },
      {
        "rule_set": "geosite-openai",
        "action": "route",
        "outbound": "openai"
      },
      {
        "rule_set": "geosite-bahamut",
        "action": "route",
        "outbound": "bahamut"
      },
      {
        "rule_set": "bilibili_domain",
        "action": "route",
        "outbound": "bilibili"
      },
      {
        "rule_set": [
          "netflix_ip",
          "netflix_domain"
        ],
        "action": "route",
        "outbound": "netflix"
      },
      {
        "rule_set": "bahamut_domain",
        "action": "route",
        "outbound": "bahamut"
      },
      {
        "rule_set": "youtube_domain",
        "action": "route",
        "outbound": "youtube"
      },
      {
        "rule_set": "openai_domain",
        "action": "route",
        "outbound": "openai"
      },
      {
        "type": "logical",
        "mode": "and",
        "rules": [
          {
            "rule_set": "proxy_domain"
          },
          {
            "invert": true,
            "rule_set": [
              "geosite-cn",
              "geosite-apple",
              "geosite-google",
              "geosite-telegram",
              "geosite-netflix"
            ]
          }
        ],
        "action": "route",
        "outbound": "proxy"
      },
      {
        "rule_set": [
          "google_ip",
          "google_domain"
        ],
        "action": "route",
        "outbound": "google"
      },
      {
        "rule_set": [
          "apple_ip",
          "apple_domain"
        ],
        "action": "route",
        "outbound": "apple"
      },
      {
        "rule_set": [
          "cn_ip",
          "cn_domain"
        ],
        "action": "route",
        "outbound": "cn"
      }
    ],
    "rule_set": [
      {
        "tag": "geosite_ads",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/category-ads-all.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite-category-ads-all",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-category-ads-all.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite_adguard",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/217heidai/adblockfilters/main/rules/adblocksingbox.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite-apple",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-apple.srs",
        "download_detour": "direct"
      },
      {
        "type": "remote",
        "tag": "geosite-bahamut",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-bahamut.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite-bilibili",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-bilibili.srs",
        "download_detour": "direct"
      },
      {
        "type": "remote",
        "tag": "geosite-cn",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-cn.srs",
        "download_detour": "direct"
      },
      {
        "type": "remote",
        "tag": "geosite-google",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-google.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite-netflix",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-netflix.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite-openai",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-openai.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite-telegram",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-telegram.srs",
        "download_detour": "proxy"
      },
      {
        "type": "remote",
        "tag": "geosite-youtube",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/SagerNet/sing-geosite/rule-set/geosite-youtube.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "apple_ip",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geoip/apple.srs",
        "download_detour": "direct"
      },
      {
        "tag": "apple_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/apple.srs",
        "download_detour": "direct"
      },
      {
        "tag": "bahamut_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/bahamut.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "bilibili_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/bilibili.srs",
        "download_detour": "direct"
      },
      {
        "tag": "cn_ip",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geoip/cn.srs",
        "download_detour": "direct"
      },
      {
        "tag": "cn_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/cn.srs",
        "download_detour": "direct"
      },
      {
        "tag": "google_ip",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geoip/google.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "google_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/google.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "netflix_ip",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geoip/netflix.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "netflix_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/netflix.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "openai_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/openai.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "proxy_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo/geosite/geolocation-!cn.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "telegram_ip",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geoip/telegram.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "telegram_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/telegram.srs",
        "download_detour": "proxy"
      },
      {
        "tag": "youtube_domain",
        "type": "remote",
        "format": "binary",
        "url": "https://ghfast.top/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/refs/heads/sing/geo-lite/geosite/youtube.srs",
        "download_detour": "proxy"
      }
    ],
    "final": "proxy",
    "auto_detect_interface": true,
    "override_android_vpn": true,
    "default_domain_resolver": "local"
  },
  "experimental": {
    "clash_api": {
      "external_controller": "127.0.0.1:9090",
      "external_ui": "ui",
      "external_ui_download_url": "https://ghfast.top/https://github.com/MetaCubeX/metacubexd/archive/refs/heads/gh-pages.zip",
      "external_ui_download_detour": "proxy",
      "default_mode": "rule"
    },
    "cache_file": {
      "enabled": true,
      "path": "cache.db",
      "cache_id": "singbox",
      "store_fakeip": true,
      "store_rdrc": true
    }
  }
};

        // ==========================================
        // 2. 工具函数
        // ==========================================
        function safeBase64Decode(str) {
            str = str.replace(/-/g, '+').replace(/_/g, '/');
            while (str.length % 4) { str += '='; }
            try { return decodeURIComponent(escape(window.atob(str))); } catch { return window.atob(str); }
        }

        function setStatus(text, type = 'normal') {
            const statusText = document.getElementById('statusText');
            const inputStatus = document.getElementById('inputStatus');
            const outputStatus = document.getElementById('outputStatus');
            
            statusText.textContent = text;
            
            if (type === 'success') {
                statusText.style.color = 'var(--success)';
                inputStatus.querySelector('.status-dot').className = 'status-dot active';
                inputStatus.querySelector('span').textContent = '内容已输入';
                outputStatus.querySelector('.status-dot').className = 'status-dot active';
                outputStatus.querySelector('span').textContent = '转换完成';
            } else if (type === 'error') {
                statusText.style.color = 'var(--error)';
                inputStatus.querySelector('.status-dot').className = 'status-dot error';
                inputStatus.querySelector('span').textContent = '输入错误';
                outputStatus.querySelector('.status-dot').className = 'status-dot';
                outputStatus.querySelector('span').textContent = '等待转换';
            } else {
                statusText.style.color = 'var(--text-primary)';
                const inputText = document.getElementById('inputArea').value.trim();
                if (inputText) {
                    inputStatus.querySelector('.status-dot').className = 'status-dot active';
                    inputStatus.querySelector('span').textContent = '内容已输入';
                } else {
                    inputStatus.querySelector('.status-dot').className = 'status-dot';
                    inputStatus.querySelector('span').textContent = '等待输入';
                }
                outputStatus.querySelector('.status-dot').className = 'status-dot';
                outputStatus.querySelector('span').textContent = '等待转换';
            }
        }

        function processWsPath(pathStr) {
            if (!pathStr) return { path: '/' };
            const edMatch = pathStr.match(/[?&]ed=(\d+)/);
            if (edMatch) {
                const maxEarlyData = parseInt(edMatch[1], 10);
                let newPath = pathStr.replace(/[?&]ed=\d+/, '');
                if (newPath.endsWith('?')) newPath = newPath.slice(0, -1);
                if (newPath === '') newPath = '/';
                return {
                    path: newPath,
                    max_early_data: maxEarlyData,
                    early_data_header_name: "Sec-WebSocket-Protocol"
                };
            }
            return { path: pathStr };
        }

        // ==========================================
        // 3. 转换逻辑 (Clash -> Singbox)
        // ==========================================
        function mapClashToSingbox(p) {
            if (!p || !p.type) return null;
            const node = { tag: p.name || 'Unnamed' };
            
            if(p.type) node.type = p.type;
            if(p.server) node.server = p.server;
            if(p.port) node.server_port = parseInt(p.port, 10);
            if(p.password) node.password = p.password;
            if(p.uuid) node.uuid = p.uuid;
            
            const applyClashWs = (target, opts, headers) => {
                const wsInfo = processWsPath(opts.path || '/');
                target.transport = {
                    type: 'ws',
                    path: wsInfo.path,
                    headers: headers || {}
                };
                if(wsInfo.max_early_data) {
                    target.transport.max_early_data = wsInfo.max_early_data;
                    target.transport.early_data_header_name = wsInfo.early_data_header_name;
                }
            };

            if (p.type === 'ss' || p.type === 'shadowsocks') {
                node.type = 'shadowsocks';
                node.method = p.cipher;
                if (p.plugin === 'v2ray-plugin' && p['plugin-opts']) {
                    const opts = p['plugin-opts'];
                    if (opts.mode === 'websocket') {
                        applyClashWs(node, opts, opts.headers || (opts.host ? {Host: opts.host} : {}));
                        if (opts.tls) {
                            node.tls = {
                                enabled: true,
                                server_name: opts.servername || opts.host || p.server,
                                insecure: opts['skip-cert-verify'] || false
                            };
                        }
                    }
                }
            } else if (p.type === 'vmess') {
                node.type = 'vmess';
                node.alter_id = p.alterId !== undefined ? parseInt(p.alterId) : 0;
                node.security = p.cipher || 'auto';
                
                if (p.network === 'ws') {
                    applyClashWs(node, p['ws-opts'] || {}, p['ws-opts']?.headers);
                } else if (p.network === 'grpc') {
                    node.transport = { type: 'grpc', service_name: p['grpc-opts']?.['grpc-service-name'] };
                }

                if (p.tls) {
                    node.tls = { 
                        enabled: true, 
                        server_name: p.servername || p.server, 
                        utls: { enabled: true, fingerprint: p['client-fingerprint'] || 'chrome' },
                        insecure: p['skip-cert-verify'] || false
                    };
                }
            } else if (p.type === 'vless') {
                node.flow = p.flow || '';
                if (p.tls) {
                    node.tls = { 
                        enabled: true, 
                        server_name: p.servername || p.server,
                        utls: { enabled: true, fingerprint: p['client-fingerprint'] || 'chrome' },
                        insecure: p['skip-cert-verify'] || false
                    };
                    if (p['reality-opts']) {
                        node.tls.reality = {
                            enabled: true,
                            public_key: p['reality-opts']['public-key'],
                            short_id: p['reality-opts']['short-id']
                        };
                    }
                }
                if (p.network === 'ws') {
                    applyClashWs(node, p['ws-opts'] || {}, p['ws-opts']?.headers);
                } else if (p.network === 'grpc') {
                    node.transport = { type: 'grpc', service_name: p['grpc-opts']?.['grpc-service-name'] };
                }
                if (node.flow === '') delete node.flow;
            } else if (p.type === 'trojan') {
                node.tls = {
                    enabled: true,
                    server_name: p.sni || p.servername || p.server,
                    utls: { enabled: true, fingerprint: p['client-fingerprint'] || 'chrome' },
                    insecure: p['skip-cert-verify'] || false
                };
                if(p.network === 'ws') {
                    applyClashWs(node, p['ws-opts'] || {}, p['ws-opts']?.headers);
                }
            } else if (p.type === 'hysteria2') {
                node.type = 'hysteria2';
                node.tls = {
                    enabled: true,
                    server_name: p.sni || p.server,
                    utls: { enabled: true, fingerprint: p['client-fingerprint'] || 'chrome' },
                    insecure: p['skip-cert-verify'] || false
                };
                if(p.obfs) {
                    node.obfs = { type: 'salamander', password: p['obfs-password'] };
                }
            }
            return node;
        }

        // ==========================================
        // 4. 链接解析逻辑
        // ==========================================
        function parseURI(line) {
            line = line.trim();
            if (!line) return null;

            try {
                const protocols = ['vless://', 'vmess://', 'ss://', 'trojan://', 'hysteria2://'];
                let startIndex = -1;
                for (let p of protocols) {
                    startIndex = line.indexOf(p);
                    if (startIndex !== -1) break;
                }
                
                if (startIndex === -1) return null;
                
                let urlStr = line.substring(startIndex);
                let uriObj;
                try {
                    uriObj = new URL(urlStr);
                } catch(e) {
                    const hashIndex = urlStr.indexOf('#');
                    if (hashIndex !== -1) {
                        const preHash = urlStr.substring(0, hashIndex);
                        const postHash = urlStr.substring(hashIndex + 1);
                        try {
                            uriObj = new URL(preHash);
                            uriObj.hash = '#' + encodeURIComponent(postHash);
                        } catch(ex) { return null; }
                    } else {
                        return null; 
                    }
                }

                const protocol = uriObj.protocol.replace(':', '');
                const params = Object.fromEntries(uriObj.searchParams);
                
                let tag = '';
                if (uriObj.hash) {
                    try { tag = decodeURIComponent(uriObj.hash.slice(1)); } 
                    catch { tag = uriObj.hash.slice(1); }
                }
                if (!tag && params.remarks) tag = decodeURIComponent(params.remarks);
                if (!tag) tag = 'Node';

                const node = {
                    tag: tag,
                    server: uriObj.hostname,
                    server_port: parseInt(uriObj.port, 10)
                };

                const applyWs = (targetNode, path, headers) => {
                    const wsInfo = processWsPath(path || '/');
                    targetNode.transport = { 
                        type: 'ws', 
                        path: wsInfo.path, 
                        headers: headers || {} 
                    };
                    if(wsInfo.max_early_data) {
                        targetNode.transport.max_early_data = wsInfo.max_early_data;
                        targetNode.transport.early_data_header_name = wsInfo.early_data_header_name;
                    }
                };

                if (protocol === 'vless') {
                    node.type = 'vless';
                    node.uuid = uriObj.username;
                    node.flow = params.flow || '';
                    if (node.flow === '') delete node.flow;

                    const isTls = params.security === 'tls' || params.security === 'reality' || params.tls === '1';
                    const isReality = params.security === 'reality';
                    
                    if (isTls) {
                        node.tls = {
                            enabled: true,
                            server_name: params.sni || params.peer || params.host || node.server,
                            utls: { enabled: true, fingerprint: params.fp || 'chrome' },
                            insecure: params.allowInsecure === '1'
                        };
                        if (isReality) {
                            node.tls.reality = {
                                enabled: true,
                                public_key: params.pbk,
                                short_id: params.sid || ''
                            };
                        }
                    }

                    const type = params.type || params.obfs;
                    if (type === 'ws' || type === 'websocket') {
                        applyWs(node, params.path, params.host ? {Host: params.host} : {});
                    } else if (type === 'grpc') {
                        node.transport = { type: 'grpc', service_name: params.serviceName || params.path || 'grpc' };
                    }

                } else if (protocol === 'vmess') {
                    if (!uriObj.username && urlStr.includes('vmess://')) {
                         const b64 = urlStr.replace('vmess://', '');
                         try {
                            const v = JSON.parse(safeBase64Decode(b64));
                            return mapClashToSingbox({
                                type: 'vmess', name: v.ps, server: v.add, port: v.port, uuid: v.id, alterId: v.aid,
                                cipher: v.scy || 'auto', network: v.net, tls: v.tls==='tls',
                                servername: v.sni || v.host, "ws-opts": {path: v.path, headers: {Host:v.host}},
                                "grpc-opts": {"grpc-service-name": v.path}
                            });
                         } catch(e) {}
                    }
                    
                    node.type = 'vmess';
                    node.uuid = uriObj.username;
                    node.alter_id = 0;
                    node.security = 'auto';

                    const type = params.obfs || params.type || 'tcp';
                    if (type === 'websocket' || type === 'ws') {
                        applyWs(node, params.path, params.obfsParam ? {Host: params.obfsParam} : {});
                    }
                    if (params.tls === '1') {
                        node.tls = { enabled: true, server_name: params.peer || params.obfsParam };
                    }

                } else if (protocol === 'trojan') {
                    node.type = 'trojan';
                    node.password = uriObj.username;
                    node.tls = {
                        enabled: true,
                        server_name: params.sni || params.peer || node.server,
                        utls: { enabled: true, fingerprint: 'chrome' }
                    };

                    const type = params.type || params.obfs;
                    const pluginStr = params.plugin || "";
                    
                    if (type === 'ws' || type === 'websocket') {
                        applyWs(node, params.path, params.host ? {Host: params.host} : {});
                    } else if (pluginStr.includes('obfs-local') && pluginStr.includes('websocket')) {
                        const pParts = pluginStr.split(';');
                        let wsPath = '/', wsHost = '';
                        pParts.forEach(p => {
                             if(p.includes('obfs-uri')) wsPath = p.split('=')[1];
                             if(p.includes('obfs-host')) wsHost = p.split('=')[1];
                        });
                        applyWs(node, wsPath, wsHost ? {Host: wsHost} : {});
                    }

                } else if (protocol === 'ss') {
                    let userInfo = uriObj.username;
                    if (!userInfo.includes(':')) {
                        const decoded = safeBase64Decode(userInfo);
                        if (decoded.includes(':')) userInfo = decoded;
                    }
                    let [method, password] = userInfo.split(':');
                    if (userInfo.includes('@')) {
                         const parts = userInfo.split('@');
                         const creds = parts[0].split(':');
                         method = creds[0];
                         password = creds[1];
                    }

                    node.type = 'shadowsocks';
                    node.method = method;
                    node.password = password;

                    const pluginStr = params.plugin || params['v2ray-plugin'] || "";
                    
                    if (pluginStr.includes('v2ray-plugin') || pluginStr.includes('obfs')) {
                         let opts = {};
                         if (!pluginStr.startsWith('{')) {
                             const parts = pluginStr.split(';');
                             parts.forEach(part => {
                                 const [k, v] = part.split('=');
                                 if(k) opts[k] = v || true;
                             });
                         }
                         
                         if (opts.mode === 'websocket' || opts.obfs === 'websocket') {
                             const host = opts.host || opts['obfs-host'];
                             applyWs(node, opts.path, host ? {Host: host} : {});
                             
                             if (opts.tls === true || opts.tls === 'true') {
                                 node.tls = {
                                     enabled: true,
                                     server_name: host || node.server
                                 };
                             }
                         }
                    }
                }
                return node.type ? node : null;
            } catch (e) { return null; }
        }

        // ==========================================
        // 5. 主转换逻辑
        // ==========================================
        function convert() {
            const rawInput = document.getElementById('inputArea').value.trim();
            if (!rawInput) {
                setStatus('请输入配置内容', 'error');
                return;
            }

            setStatus('正在解析混合内容...', 'normal');
            let nodes = [];
            
            let input = rawInput;
            if (!input.includes('://') && !input.includes('outbounds') && !input.includes('proxies:')) {
                const decoded = safeBase64Decode(input);
                if (decoded && (decoded.includes('://') || decoded.includes('proxies:'))) {
                    input = decoded;
                }
            }

            const yamlLines = [];
            const lines = input.split(/\r?\n/);
            lines.forEach(line => {
                const trimmed = line.trim();
                if (trimmed.startsWith('- {') && trimmed.includes('name:') && trimmed.includes('type:')) {
                    yamlLines.push(trimmed);
                }
            });

            if (yamlLines.length > 0) {
                try {
                    const fakeYaml = "proxies:\n" + yamlLines.join("\n");
                    const parsed = jsyaml.load(fakeYaml);
                    if (parsed && parsed.proxies) {
                        parsed.proxies.forEach(p => {
                            const node = mapClashToSingbox(p);
                            if (node) nodes.push(node);
                        });
                    }
                } catch (e) { console.warn("YAML fragment parse error", e); }
            }

            if (input.includes('"outbounds"')) {
                try {
                    let jsonParsed = false;
                    try {
                        const j = JSON.parse(input);
                        if(j.outbounds) {
                            j.outbounds.forEach(o => {
                                if(o.type !== 'selector' && o.type !== 'urltest' && o.type!=='direct') nodes.push(o);
                            });
                            jsonParsed = true;
                        }
                    } catch(e) {}
                    if (!jsonParsed) {
                        const match = input.match(/"outbounds"\s*:\s*(\[[\s\S]*?\])/);
                        if (match) {
                            const arrStr = match[1];
                            const lastBracket = arrStr.lastIndexOf(']');
                            const validJsonArr = arrStr.substring(0, lastBracket+1);
                            const arr = JSON.parse(validJsonArr);
                            arr.forEach(o => {
                                if(o.type !== 'selector' && o.type !== 'urltest' && o.type!=='direct') nodes.push(o);
                            });
                        }
                    }
                } catch (e) { console.warn("JSON fragment parse error", e); }
            }

            lines.forEach(line => {
                if (line.trim().startsWith('- {')) return;
                const node = parseURI(line);
                if (node) nodes.push(node);
            });

            if (nodes.length === 0) {
                setStatus('未找到有效节点', 'error');
                return;
            }

            const uniqueNodes = [];
            const tagCounts = {};

            nodes.forEach(node => {
                let tag = node.tag || 'node';
                if (tagCounts[tag]) {
                    tagCounts[tag]++;
                    tag = `${tag} ${tagCounts[tag]}`;
                } else {
                    tagCounts[tag] = 1;
                }
                node.tag = tag;
                uniqueNodes.push(node);
            });

            const finalConfig = JSON.parse(JSON.stringify(TEMPLATE));
            const nodeTags = uniqueNodes.map(n => n.tag);
            
            const proxySelector = finalConfig.outbounds.find(o => o.tag === 'proxy');
            if (proxySelector && proxySelector.type === 'selector') {
                proxySelector.outbounds = ["auto", ...nodeTags, "direct"];
            }
            
            const autoUrlTest = finalConfig.outbounds.find(o => o.tag === 'auto');
            if (autoUrlTest && autoUrlTest.type === 'urltest') {
                autoUrlTest.outbounds = nodeTags;
            }

            finalConfig.outbounds.push(...uniqueNodes);

            document.getElementById('outputArea').value = JSON.stringify(finalConfig, null, 2);
            setStatus(`成功转换 ${uniqueNodes.length} 个节点`, 'success');
            document.getElementById('nodeCount').textContent = uniqueNodes.length;
        }

        function clearInput() {
            document.getElementById('inputArea').value = '';
            document.getElementById('outputArea').value = '';
            setStatus('已清空', 'normal');
            document.getElementById('nodeCount').textContent = '0';
        }

        function copyResult() {
            const output = document.getElementById('outputArea');
            if (output.value) {
                output.select();
                document.execCommand('copy');
                setStatus('已复制到剪贴板', 'success');
            } else {
                setStatus('没有内容可复制', 'error');
            }
        }

        window.addEventListener('load', () => {
            setStatus('就绪', 'normal');
        });
    </script>
</body>
</html>
